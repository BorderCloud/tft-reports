<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>SPARQL (Core) 1.1 : Test Suite Report</title>


    <script class='remove'>
      var respecConfig = {
        specStatus: "WD",
        specStatus:"unofficial",
        editors: [
		{
		  name: "Karima Rafes",
                    url:        "http://karimarafes.me/",
                    company:    "BorderCloud",
                    companyURL: "http://bordercloud.com"
		}
		//,
		// {
		//   name: "Axel Polleres",
        //             company: "Siemens AG"
		// },
		// {
		//   name: "Steve Harris",
        //           company: "IAM Research Group, Southampton"
		// },
		// {
		//   name: "Jeen Broekstra",
        //           company: "Information Systems Group, Eindhoven University of Technology"
		// },
		// {
		//   name: "Lee Feigenbaum",
        //           company: "Cambridge Semantics"
		// }
		 ],
        processVersion: 2018,
        edDraftURI: "https://github.com/BorderCloud/tft-reports",
        shortName: "tft-reports",
	//previousURI: "https://w3c.github.io/rdf-tests/sparql11/",
          lint: false,

          "license":"cc0",
      };
    </script>
  </head>
  <body>

	<section id='abstract'><h2 id="abstract-0">Abstract</h2>
		<p>
			This document describe a method to execute the SPARQL test suite (of w3c/rdf-tests) with in input several docker's instances of SPARQL services.
            This document is also a demonstrator uses  SPARQL queries directly in the HTML.		</p>
        <p>
            You can star this work:<br/>
            <iframe src="https://ghbtns.com/github-btn.html?user=bordercloud&repo=tft-reports&type=star&count=true&size=large" frameborder="0" scrolling="0" width="160px" height="30px"></iframe><br/>if you find it interesting or want to come back.
		</p>
	</section>

    <section id="sotd" class="introductory">

    </section>

    <section class="introductory"><h2>Introduction</h2>
        <p>

            This document is a draft (work in progress) to visualize the actual interoperability  between several editors of SPARQL service (another version to look these results with more details : <a href="http://sparqlscore.com/">SPARQLScore</a>).
            It uses a new method to execute the SPARQL test suite in the cloud (reproducible free).

        </p>
        <p>

            Already, this document describes several scripts to execute a part of SPARQL (core) test suite (of w3c/rdf-tests) with docker's instances of RDF databases.
            These scripts can be used locally or in the cloud (via GitHub and the continuous integration service of Travis CI).

        </p>
        <p>

            This document is also a demonstrator : all tables in this HTML document are the results of SPARQL queries (look the code).
            This document is a demonstrator and a draft to visualize the actual interoperability  between several editors of SPARQL service.
            (another version to look these results with more details : <a href="http://sparqlscore.com/">SPARQLScore</a>).

        </p>
  </section>


    <section ><h2>Tests/tools/software</h2>
        <p>
            This document is a demonstrator for the W3C working groups and uses :
        <ul>
            <li><a href="https://github.com/w3c/respec">ReSpec, a tool for creating technical documents and web standards</a></li>
            <li><a href="https://github.com/BorderCloud/sgvizler2">
                Sgvizler2, a tool for easy visualisation a SPARQL result in a HTML page.</a></li>
        </ul>

        To execute the tests of W3C in this document, we use :
        <ul>
            <li><a href="https://github.com/BorderCloud/TFT">
                TFT (Tester for Triplestore), a script PHP to pass tests through a sparql endpoint.</a></li>
            <li><a href="https://github.com/BorderCloud/SPARQL">
                BorderCloud/SPARQL, very simple SPARQL client for PHP.</a></li>
        </ul>

        Only a part of tests of W3C are useable by TFT :
        <ul>
            <li><a href="http://w3c.github.io/rdf-tests/sparql11/">
                Specification of tests</a></li>
            <li><a href="https://github.com/w3c/rdf-tests/tree/gh-pages/sparql11/data-sparql11">Tests of W3C on GitHub</a></li>
        </ul>


        Thanks at editors of RDF databases who made this work possible  :
        <ul>
            <li><a href="https://www.blazegraph.com/">Blazegraph</a></li>
            <li><a href="https://jena.apache.org/documentation/fuseki2/index.html">Jena-Fuseki</a></li>
            <li><a href="https://www.stardog.com/">Stardog</a></li>
            <li><a href="https://virtuoso.openlinksw.com/">OpenLink Virtuoso</a></li>
        </ul>

        Thanks at services who host/execute this project  :
        <ul>
            <li><a href="https://github.com/">Github</a></li>
            <li><a href="https://travis-ci.org/">Travis-ci</a></li>
            <li><a href="https://www.docker.com/">Docker</a></li>
        </ul>

        Thanks at the <a href="https://www.universite-paris-saclay.fr/en">University Paris-Saclay</a>  that hosts the SPARQL service to share the results of these tests.
        </p>
    </section>




	<!--<section>-->
		<!--<h2>Namespace prefixes</h2>-->
		<!--<p>-->
			<!--In this document we will employ the following namespace prefixes:-->
		<!--</p>-->

		<!--<dl>-->
			<!--<dt><code>earl</code></dt>-->
			<!--<dd><code><a href="http://www.w3.org/ns/earl#">http://www.w3.org/ns/earl#</a></code></dd>-->
		<!--</dl>-->

	<!--</section>-->

<!--<section>-->
	<!--<h2>Test Cases Format and Process</h2>-->

  	<!--<div class="issue" id="issue-A">-->
			<!--<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">-->
				<!--<span>TODO A</span><span style="text-transform: none"></span>-->
			<!--</div>-->
			<!--<div class="">-->
			  <!--<p>-->
			  <!--changer cette partie-->
			  <!--</p>-->
			<!--</div>-->
		<!--</div>-->
  <!--<p>-->


<!--<section>-->
<!--The-->
<!--<a href="http://www.w3.org/2009/sparql/wiki/">SPARQL Working Group</a> uses a test-driven process.&nbsp; The <a href="http://www.w3.org/2009/sparql/docs/tests">test area</a> is a-->
<!--collection of the current test cases of the working group extending and updating the <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">testcases</a> of the <a href="http://www.w3.org/2001/sw/DataAccess/">Data Access Working Group</a>. </p>-->
  <!--<p>-->
<!--Tests are divided into collections (corresponding to directories) for manageability.&nbsp; Each collection-->
<!--of tests has a <em>manifest file</em> within its directory (usually named-->
<!--<tt>manifest.ttl</tt>, but sometimes <tt>manifest.n3</tt>).-->
<!--There is also a number of overall manifests containing entries pointing to the-->
<!--individual test collection manifests:</p>-->

    <!--&lt;!&ndash;old version-->
<!--<ul>-->
<!--<li><a-->
<!--href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/manifest-syntax.ttl">manifest-->
<!--of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL1.0 Query Language</a></li>-->
<!--<a-->
<!--href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/manifest-evaluation.ttl">manifest-->
<!--of query-evaluation tests</a> for the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL1.0 Query Language</a>.</li>-->
<!--<li><a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-query-syntax.ttl">manifest of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query Language</a></li>-->
  <!--<li><a-->
<!--href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-query-evaluation.ttl">manifest of query evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query Language</a></li>-->
  <!--<li><a-->
<!--href="data-sparql11/entailment/manifest.ttl">manifest of entailment evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL1.1 Entailment Regimes</a></li>-->
  <!--<li><a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-update-syntax.ttl">manifest of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update Language</a></li>-->
  <!--<li><a-->
<!--href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-update-syntax.ttl">manifest of update evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update Language</a></li>-->
  <!--<li><a-->
<!--href="data-sparql11/service-description/manifest.ttl">manifest of service description tests</a> for the <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL1.1 Service Description</a></li>-->
<!--</ul>-->
<!--&ndash;&gt;-->
    <!--<div id="resulth"-->
         <!--data-sgvizler-query="PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;-->
<!--PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;-->
<!--prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;-->

<!--SELECT  (?specLink as ?Specification)   (group_concat(?manifestLink) as ?Manifests)-->
<!--WHERE {-->
<!--GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt;  {-->
        <!--?spec  mf:conformanceRequirement   ?collection .-->
        <!--?spec  rdfs:label   ?label .-->
        <!--?collection 	rdf:rest*/rdf:first  ?manifest .-->
        <!--OPTIONAL{-->
       <!--?manifest rdfs:label   ?manifestLabel .-->
     <!--}-->

         <!--BIND( concat('&lt;a href=\'',str(?manifest),'\'&gt;',IF(bound(?manifestLabel), ?manifestLabel, 'no label') ,'&lt;/a&gt;') as ?manifestLink)-->
    <!--BIND( concat('&lt;a href=\'',str(?spec),'\'&gt;',?label ,'&lt;/a&gt;') as ?specLink)-->
    <!--}-->
    <!--}-->
    <!--GROUP BY ?specLink-->
    <!--ORDER BY ?specLink"-->
    <!--data-sgvizler-endpoint="http://134.158.74.247/test/query"-->
    <!--data-sgvizler-chart="sgvizler.visualization.Table"-->
    <!--data-sgvizler-log="2"-->
    <!--data-sgvizler-method="POST"-->
    <!--&gt;</div>-->

<!--</section>-->

<!--<section>-->
<!--<h4><a name="organization" id="organization"/>Organization</a></h4>-->
<!--<p>-->
<!--The test cases are organised in two directories</p>-->
<!--<ul>-->
  <!--<li>The <a href="http://www.w3.org/2009/sparql/docs/tests/data-r2/">data-r2</a> directory holds the testcases from the previous <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">testcases</a>SPARQL1.0 Query language test suite @@@plus new tests that are restricted to SPARQL 1.0 features only??? @@@.</li>-->
  <!--<li>The <a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11">data-sparql11</a> directory holds test cases aimed at covering as much of the SPARQL 1.1 Query Language and SPARQL 1.1 Update Language as possible.</li>-->
<!--</ul>-->
  <!--The purpose is to provide an up-to-date, upwards-compatible, consistent, and easy-to-use suite of test cases that SPARQL 1.1 implementors can use to evaluate and report on their-->
<!--implementation.-->
<!--</p>-->
<!--<p>-->
<!--The tests as-is shall constitute a test suite that the group will-->
<!--use to generate an implementation report for the SPARQL1.1 Query  and SPARQL1.1 Update languages.</p>-->
<!--<p><b>@@@ What about other tests, will we use the same structure for e.g. http-update, service-description tests, will we (a) have separate manifest(s) for entailment?</b></p>-->
<!--</p>-->
<!--</section>-->

<!--<section>-->
  <!--<h4><a name="vocabularies" id="vocabularies"/>Manifest Vocabularies</a></h4>-->

  <!--<p>The SPARQL1.1 test manifest files define five vocabularies to express-->
  <!--tests and results:</p>-->

  <!--<ol>-->
    <!--<li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-manifest.n3">manifest vocabulary</a> (prefixed with-->
    <!--<tt>mf:</tt> below)</li>-->
    <!--<li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-query.n3">query evaluation test vocabulary</a> (prefixed-->
    <!--with <tt>qt:</tt> below)</li>-->
    <!--<li><a href="test-update.n3">update evaluation test vocabulary</a> (prefixed-->
    <!--with <tt>ut:</tt> below)</li>-->
    <!--<li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-dawg.n3">DAWG test approval vocabulary</a> (prefixed-->
    <!--with <tt>dawgt:</tt> below)</li>-->
    <!--<li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-dawg.n3">DAWG result-set RDF vocabulary</a> (prefixed-->
    <!--with <tt>rs:</tt> below)</li>-->
  <!--</ol>-->

  <!--<p>All examples below use these prefix bindings (specified in <a-->
  <!--href="http://www.w3.org/2001/sw/DataAccess/df1/">turtle</a>):</p>-->

  <!--<pre class="diag">@prefix rdf:     &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .-->
<!--@prefix rdfs:    &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .-->
<!--@prefix mf:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; .-->
<!--@prefix dawgt:   &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt; .-->
<!--@prefix qt:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; .-->
<!--@prefix ut:      &lt;http://www.w3.org/2009/sparql/tests/test-update#&gt; .-->
<!--@prefix sd:      &lt;http://www.w3.org/ns/sparql-service-description#&gt; .-->
<!--@prefix ent:     &lt;http://www.w3.org/ns/entailment/RDF&gt; .-->
<!--@prefix rs:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/result-set#&gt; .-->
  <!--</pre>-->

  <!--<h4><a name="structure" id="structure"/>Manifest Structure</a></h4>-->

  <!--<p>-->
<!--A manifest is a list (RDF Collection) of tests. Every test has-->
<!--a name (<tt>mf:name</tt>); many tests also have a comment-->
<!--(<tt>rdfs:comment</tt>) explaining the purpose of the test.-->
<!--The <tt>dawgt:approval</tt> predicate relates a test to its official-->
<!--Working Group status (e.g. <tt>dawgt:Approved</tt>).-->
<!--Tests are grouped (via their <tt>rdf:type</tt>) as:-->
<!--</p>-->

<!--<ul>-->
	<!--<li>positive SPARQL 1.0 Query syntax tests (<tt>mf:PositiveSyntaxTest</tt>)</li>-->
	<!--<li>positive SPARQL 1.1 Query syntax tests (<tt>mf:PositiveSyntaxTest11</tt>)</li>-->
	<!--<li>positive SPARQL 1.1 Update syntax tests (<tt>mf:PositiveUpdateSyntaxTest11</tt>)</li>-->
	<!--<li>negative SPARQL 1.0 Query syntax tests (<tt>mf:NegativeSyntaxTest</tt>)</li>-->
	<!--<li>negative SPARQL 1.1 Query syntax tests (<tt>mf:NegativeSyntaxTest11</tt>)</li>-->
	<!--<li>negative SPARQL 1.1 Update syntax tests (<tt>mf:NegativeUpdateSyntaxTest11</tt>)</li>-->
	<!--<li>SPARQL 1.0 and 1.1 Query evaluation tests (<tt>mf:QueryEvaluationTest</tt>)</li>-->
	<!--<li>SPARQL 1.1 Update evaluation tests (<tt>mf:UpdateEvaluationTest</tt>)</li>-->
	<!--<li>CSV Result Format tests (<tt>mf:CSVResultFormatTest</tt>)</li>-->
	<!--<li>SPARQL 1.1 Service Description tests (<tt>mf:ServiceDescriptionTest</tt>)</li>-->
<!--</ul>-->
<!--</section>-->

<!--<section>-->
  <!--<h4><a name="filenames" id="filenames"/>File Names</a></h4>-->

 <!--<p>Typically, in the test case suite, we use the following suffixes to indicate different file types:</p>-->
 <!--<ul>-->
    <!--<li><b>.ttl</b> ... Files describing RDF graphs in <a href="http://www.w3.org/TeamSubmission/turtle/">Turtle</a> syntax.-->
    <!--</li>-->
    <!--<li><b>.rdf</b> ... Files describing RDF graphs in <a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> syntax.-->
    <!--</li>-->
    <!--<li><b>.rq</b> ... Files containing a <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query</a> request.-->
    <!--</li>-->
    <!--<li><b>.ru</b> ... Files containing a <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update</a> request.-->
    <!--</li>-->
    <!--<li><b>.srx</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a>.-->
    <!--</li>-->
    <!--<li><b>.srj</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON Format</a>.-->
    <!--</li>-->
    <!--<li><b>.csv</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results CSV (Comma Separated Values) Format</a>.-->
    <!--</li>-->
    <!--<li><b>.tsv</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results TSV (Tab Separated Values) Format</a>.-->
    <!--</li>-->
  <!--</ul>-->
<!--<p>@@@ Fix/check final URL for http://www.w3.org/TR/sparql11-results-json/!</p>-->

 <!--<p>@@@ Will we update the SPARQL Query Results XML Format spec for SPARQL1.1?</p>-->
<!--</section>-->

<!--<section>-->
  <!--<h4><a name="syntaxtests" id="syntaxtests"/>Syntax Tests</a></h4>-->

  <!--<p>-->
<!--Each syntax test has an <tt>mf:action</tt>, the object of which is a-->
<!--resource identifying a (possible) query string. An example definition of a-->
<!--syntax test is:-->
  <!--</p>-->

<!--<pre class="diag">-->
<!--&lt;#syntax-basic-01&gt;  mf:name  "syntax-basic-01.rq" ;-->
     <!--rdf:type   mf:PositiveSyntaxTest ;-->
     <!--mf:action  &lt;syntax-basic-01.rq&gt; ;-->
     <!--dawgt:approvedBy &lt;http://lists.w3.org/Archives/Public/public-rdf-dawg/2007JanMar/0047&gt; ;-->
     <!--dawgt:approval dawgt:Approved .-->
<!--</pre>-->

<!--<p>-->
<!--A SPARQL implementation passes a <tt>mf:PositiveSyntaxTest</tt> if it parses-->
<!--the query string without error. A SPARQL implementation passes a-->
<!--<tt>mf:NegativeSyntaxTest</tt> if it raises an error while attempting to parse-->
<!--the query string.-->
<!--</p>-->
<!--</section>-->

<!--<section>-->
  <!--<h4><a name="queryevaltests" id="queryevaltests"/>Query Evaluation Tests</a></h4>-->

  <!--<p>Each query evaluation test has an <tt>mf:action</tt> and an-->
  <!--<tt>mf:result</tt>. The object of <tt>mf:action</tt> is a resource with-->
  <!--properties taken from the query evaluation test vocabulary. At a minimum, a-->
  <!--test's action includes  a <tt>qt:query</tt>-->
  <!--relation and an optional <tt>qt:data</tt> relation. The <tt>qt:data</tt>-->
  <!--predicate points to a URI that can be dereferenced to yield the-->
  <!--default graph for the test. The <tt>qt:query</tt> prediate points to a-->
  <!--URI that can be dereferenced to yield the query string for the test. Query evaluation tests may also use the <tt>qt:graphData</tt> predicate to indicate the named graph components of the test's RDF dataset.</p>-->

  <!--<p>In case the query in the <tt>qt:query</tt> predicate contains  <tt>FROM</tt> and <tt>FROM NAMED</tt> clauses and no <tt>qt:data</tt> is present, the graphs comprising the test's RDF dataset are expected to be loaded by dereferencing the respective URIs of the <tt>FROM/FROM NAMED</tt> clauses.</p>-->

  <!--<p>Query evaluation tests also contain an <tt>mf:result</tt> which points to-->
  <!--a URI that can be dereferenced to yield the-->
  <!--expected results of the test query. These results are expressed in one of-->
  <!--several possible ways:</p>-->

  <!--<ul>-->
    <!--<li>The <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query-->
    <!--Results XML Format</a>. SELECT or ASK queries.</li>-->
    <!--<li>The <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL Query-->
    <!--Results JSON Format</a>. SELECT or ASK queries.</li>-->
    <!--<li>The <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/#tsv">SPARQL Query-->
    <!--Results TSV Format</a>. SELECT or ASK queries. (As for testing the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/#csv">SPARQL Query-->
    <!--Results CSV Format</a>, see the separate Section within this document on <a href="#csvtests">CSV Result Format Tests</a>).</li>-->
    <!--<li>The <a href="http://www.w3.org/2001/sw/DataAccess/tests/result-set.n3">DAWG result-set RDF vocabulary</a>.-->
    <!--SELECT or ASK queries.</li>-->
    <!--<li><a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> or <a-->
    <!--href="http://www.dajobe.org/2004/01/turtle/">Turtle</a>. CONSTRUCT queries.</li>-->
  <!--</ul>-->

<!--<p>A SPARQL implementation passes a query evaluation test if the graph-->
<!--produced by evaluating the query against the RDF dataset (and encoding in the-->
<!--DAWG result set vocabulary, if necessary) is-->
<!--<a href="http://www.w3.org/TR/rdf-concepts/#section-graph-equality">equivalent</a> [RDF-CONCEPTS]-->
<!--to the graph named in the result (after encoding in the DAWG result set-->
<!--vocabulary, if necessary).  Note that, solution order only is considered relevant, if the result is expressed in the test suite in the DAWG result set vocabulary, with explicit <code>rs:index</code> triples; otherwise solution order is considered irrelevant for passing. Equivalence can be tested by-->
<!--checking that the graphs are isomorphic and have identical IRI and-->
<!--literal nodes. Note that testing whether two result sets are isomorphic is simpler than full graph isomorphism. Iterating over rows in one set, finding a match with the other set, removing this pair, then making sure all rows are accounted for, achieves the same effect. </p>-->

<!--<p>Query evaluation tests that involve the <a href="http://www.w3.org/TR/rdf-sparql-query#modReduced">REDUCED</a> keyword have slightly different passing criteria. These tests are indicated in the manifest files with the <tt>mf:resultCardinality</tt> predicate with an object of <tt>mf:LaxCardinality</tt>. To pass such a test, the result set produced by a SPARQL implementation must contain each solution in the expected result set at least once and no more than the number of times that the solution occurs in the expected result set. (That is, the expected result set contains the solutions with cardinalities as they would be if the query did not contain REDUCED; to pass the test, an implementation must produce the correct results with cardinalities between one and the cardinlity in the expected result set.)</p>-->

<!--<p>An example definition of a query evaluation test is:</p>-->

<!--<pre class="diag">-->
<!--&lt;#dawg-regex-002&gt; a mf:QueryEvaluationTest ;-->
      <!--mf:name    "regex-query-002" ;-->
      <!--dawgt:approval dawgt:Approved ;-->
      <!--dawgt:approvedBy &lt;http://lists.w3.org/Archives/Public/public-rdf-dawg/2007AprJun/0029.html&gt; ;-->
      <!--rdfs:comment-->
          <!--"Case insensitive unanchored match test" ;-->
      <!--mf:action-->
          <!--[ qt:query  &lt;regex-query-002.rq&gt; ;-->
            <!--qt:data   &lt;regex-data-01.n3&gt; ] ;-->
      <!--mf:result  &lt;regex-result-002.n3&gt; .-->
<!--</pre>-->
<!--</section>-->

<!--<section>-->
  <!--<h4><a name="csvtests" id="csvtests"/>CSV Result Format Tests</a></h4>-->

  <!--<p>-->
<!--CSV Result Format tests are meant to test a SPARQL implementation's ability to serialize query results in the SPARQL 1.1 Query Results CSV Format.-->
<!--This is a lossy format, however, and so cannot be tested in the same manner as the other result formats.-->
<!--Care should be taken to ensure that results produced in the CSV format are compared properly to the expected result values.-->
<!--In all other respects, CSV tests should be treated as <a href="#queryevaltests">query evaluation tests</a>.-->
  <!--</p>-->

<!--<p>An example result set in the CSV Format is:</p>-->
<!--<pre class="diag">-->
<!--s,p,o-->
<!--http://example.org/s2,http://example.org/p2,2.2-->
<!--</pre>-->

<!--<p>Due to the lossy nature of the CSV format, the single expected result could match any of the following actual results:</p>-->

<!--<ul>-->
	<!--<table class="plain">-->
	<!--<tr>-->
		<!--<th>s</th>-->
		<!--<th>p</th>-->
		<!--<th>o</th>-->
	<!--</tr>-->
	<!--<tr>-->
		<!--<td>&lt;http://example.org/s2&gt;</td>-->
		<!--<td>&lt;http://example.org/p2&gt;</td>-->
		<!--<td>"2.2"</td>-->
	<!--</tr>-->
	<!--<tr>-->
		<!--<td>&lt;http://example.org/s2&gt;</td>-->
		<!--<td>&lt;http://example.org/p2&gt;</td>-->
		<!--<td>"2.2"^^xsd:string</td>-->
	<!--</tr>-->
	<!--<tr>-->
		<!--<td>&lt;http://example.org/s2&gt;</td>-->
		<!--<td>&lt;http://example.org/p2&gt;</td>-->
		<!--<td>"2.2"^^xsd:decimal</td>-->
	<!--</tr>-->
	<!--</table>-->
<!--</ul>-->



<!--</section>-->

<!--<section>-->
  <!--<h4><a name="entailevaltests" id="entailevaltests"/>Entailment Evaluation Tests</a></h4>-->

<!--<p>Entailment Evaluation tests are special query evaluation tests that additionally (slightly ab-)use the <tt>sd:entailmentRegime</tt> and, optionally, the <tt>sd:entailmentProfile</tt> properties from the <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL 1.1 Service Description<a> vocabulary to further specify the  object of the <tt>mf:action</tt> property, indicating the expected entailment regime for graphs in the dataset and, where applicable, which OWL profile that test satisfies.</p>-->

<!--<p>A SPARQL implementation passes a query evaluation test if its-->
<!--answers over any graphs in the dataset using the <tt>sd:entailmentRegime</tt>-->
<!--property comply with the criteria formalised in the-->
<!--<a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL 1.1 Entailment Regimes<a> document. Apart from that, passing tests is as defined for query evaluation tests.</p>-->

<!--<p>An example definition of an entailment evaluation test for the RDF entailment regime is:</p>-->

<!--<pre class="diag">-->
<!--:rdf01 rdf:type mf:QueryEvaluationTest ;-->
    <!--mf:name    "RDF inference test" ;-->
    <!--dawgt:approval dawgt:NotClassified ;-->
    <!--mf:action-->
         <!--[ qt:query  &lt;rdf01.rq&gt; ;-->
           <!--qt:data   &lt;rdf01.ttl&gt;-->
           <!--sd:entailmentRegime ent:RDF ] ;-->
    <!--mf:result  &lt;rdf01.srx&gt;-->
    <!--.-->
 <!--</pre>-->

<!--<p>Instead of a single entailment regime, tests can also be marked with a list of regimes. In this case,-->
<!--any of the entailment regimes can be used to run the test. Similarly, the supported OWL profiles can be given as a-->
<!--list or as a single value:</p>-->

<!--<pre class="diag">-->
    <!--:sparqldl-10  rdf:type   mf:QueryEvaluationTest ;-->
         <!--mf:name  "sparqldl-10.rq: undist vars test" ;-->
         <!--mf:action-->
                <!--[ qt:query  <sparqldl-10.rq> ;-->
                <!--qt:data <data-07.ttl> ;-->
           <!--sd:EntailmentProfile ( pr:DL pr:EL pr:Full ) ;-->
           <!--sd:entailmentRegime ( ent:OWL-Direct ent:OWL-RDF-Based )  ] ;-->
         <!--mf:result  <sparqldl-10.srx> .-->
<!--</pre>-->

<!--<p>Note that, strictly speaking, this use of the <tt>sd:entailmentRegime</tt></a> property - by its specified <a href="http://www.w3.org/TR/sparql11-service-description/#sd-entailmentRegime">domain</a> - makes the object of the <tt>mf:action</tt> attribute a member of the <tt>sd:NamedGraph</tt> class; the <tt>sd:NamedGraph</tt> class though has no meaning within the context of test cases, so this domain specification can be savely ignored.</p>-->

<!--</section>-->

<!--<section>-->
  <!--<h4><a name="updateevaltests" id="updateevaltests"/>Update Evaluation Tests</a></h4>-->

  <!--<p>Each update evaluation test has an <tt>mf:action</tt> and an-->
  <!--<tt>mf:result</tt>. The object of <tt>mf:action</tt> for an Update evaluation test case is a resource with properties taken from the update evaluation test vocabularies.-->
  <!--The latter is used among others to describe the graph store's state before and after the execution of an update.  At a minimum, a test's action includes a <tt>ut:request</tt> relation.</p>-->

<!--<p>The optional <tt>ut:data</tt> and <tt>ut:graphData</tt> relations within the <tt>mf:action</tt> of an update test case point the status of the <a href="http://www.w3.org/TR/sparql11-update/#sec_graphStore">Graph Store</a> <i>prior</i> to the update execution described in terms of at most one <tt>ut:data</tt> property denoting the unnamed graph and optional <tt>ut:graphData</tt> properties denoting named graphs.-->
 <!--The object of the <tt>ut:data</tt> property is a URI reference to an RDF graph, whereas the objects of the <tt>ut:graphData</tt> property indicate the named graph components of the Graph Store. Named graphs are described either - analogous to the <tt>qt:graphData</tt> property from the query test vocabulary - by explicit URI reference (in which case the graph name is supposed to correspong to the respective URI reference), or the object of the <tt>ut:graphData</tt> property may be a resource further described in terms of an <tt>ut:graph</tt> and an <tt>rdfs:label</tt> property. Here, the <tt>ut:graph</tt> property is a URI reference to an RDF graph, whereas the <tt>rdfs:label</tt> property with plain literal value indicates the graph's name under which it is accessible in the graph store. The ability to assign a "name" different from the URI reference name explicitly to a named graph in a graph store is needed to denote different graphs by the same name to describe the status of a named graph prior and after execution of an update.</p>-->

<!--<p>In the case of absence of both <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within the <tt>mf:action</tt>, the graph store is supposed to be empty (i.e., with an empty default graph and no named graphs) prior to execution of the update.-->
<!--</p>-->

<!--<p>-->
<!--The-->
  <!--<tt>ut:request</tt> predicate points to a URI that can be dereferenced to yield-->
  <!--the update query string for the test.</p>-->

  <!--<p>Update evaluation tests also contain an <tt>mf:result</tt>. The object of <tt>mf:result</tt> is a resource described in terms of the <tt>ut:data</tt> and <tt>ut:graphData</tt> properties. The optional <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within a an update evaluation test result denote the state of the graphstore <i>after</i> execution of the query analogous to the  <tt>ut:data</tt> and <tt>ut:graphData</tt> properties occurring in the <tt>mf:action</tt> of an update evaluation test.-->
<!--In the case of absence of both <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within the <tt>mf:result</tt>, the graph store is supposed to be empty after execution of the update.-->
<!--</p>-->

<!--<p>A SPARQL implementation passes a update evaluation test if the graphs in the graph store are-->
<!--<a href="http://www.w3.org/TR/rdf-concepts/#section-graph-equality">equivalent</a> [RDF-CONCEPTS]-->
<!--to the graphs denoted in the <tt>mf:action</tt> (and <tt>mf:result</tt>) property, respectively) prior to the update execution (after update execution, respectively). Equivalence can be tested as described above for query evaluation tests.</p>-->

<!--<p>An example definition of an update evaluation test is:</p>-->

<!--<pre class="diag">-->
<!--:insert-data-spo1 a mf:UpdateEvaluationTest ;-->
    <!--mf:name    "Simple insert data 1" ;-->
    <!--rdfs:comment "This is a simple insert of a single triple to the unnamed graph of an empty graph store" ;-->
    <!--dawgt:approval dawgt:NotClassified ;-->
    <!--mf:action [-->
                <!--ut:request &lt;insert-data-spo1.ru&gt; ;-->
                <!--ut:data &lt;empty.ttl&gt;-->
              <!--] ;-->
    <!--mf:result [-->
                <!--ut:data  &lt;spo.ttl&gt;-->
              <!--] .-->
<!--</pre>-->
<!--</section>-->

<!--<section>-->
<!--<h4><a name="servicetests" id="servicetests"/>Federated Query Tests</a></h4>-->

<!--<p>In SPARQL 1.1 Federated Query, tests cases contain new vocabulary not used before. These tests check whether the queries with that operator are correct or not. Queries using the <code>SERVICE</code> keyword for accessing remote SPARQL endpoints need a way to describe the data comming from these endpoints which was not previously defined.</p>-->

<!--<p>The predicate <code>qt:serviceData</code> helps to describe the data comming from these remote SPARQL endpoints in a query. This predicate can also contain the predicate <code>qt:endpoint</code> which contains the URL of the remote SPARQL endpoint.</p>-->

<!--<p>An example definition of a Federated Query test is:</p>-->

<!--<pre class="diag">-->
<!--:service1 rdf:type mf:QueryEvaluationTest ;-->
       <!--mf:name    "SERVICE test 1" ;-->
       <!--dawgt:approval dawgt:NotClassified ;-->
       <!--mf:feature sd:BasicFederatedQuery ;-->
       <!--mf:action [-->
               <!--qt:query  &lt;service01.rq&gt; ;-->
               <!--qt:data   &lt;data01.ttl&gt; ;-->
               <!--qt:serviceData [-->
                       <!--qt:endpoint &lt;http://example.org/sparql&gt; ;-->
                       <!--qt:data     &lt;data01endpoint.ttl&gt;-->
               <!--]-->
       <!--] ;-->
       <!--mf:result  &lt;service01.srx&gt; .</pre>-->


<!--</section>-->

<!--<section>-->
<!--<h4><a name="protocoltests" id="protocoltests"/>Protocol Tests</a></h4>-->

<!--<p>A testing service for <a href="http://www.w3.org/TR/sparql11-protocol/">SPARQL 1.1 Protocol</a> implementations has been set up at <tt><a href="http://www.w3.org/2009/sparql/protocol_validator">http://www.w3.org/2009/sparql/protocol_validator</a></tt>. The service and tests performed by this service are described in a <a href="https://github.com/kasei/sparql11-protocolvalidator">separate document</a>.</p>-->
<!--</section>-->

<!--<section>-->
<!--<h4><a name="servicedescriptiontests" id="servicedescriptiontests"/>Service Description Tests</a></h4>-->

<!--<p>A testing service for SPARQL 1.1 Protocol implementations supporting <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL 1.1 Service Descriptions</a> has been set up at <tt><a href="http://www.w3.org/2009/sparql/sdvalidator">http://www.w3.org/2009/sparql/sdvalidator</a></tt>. The service performs a number of tests to verify that a submitted endpoint returns RDF that conforms to the service description vocabulary specification. Using content negotiation to request RDF (supporting both Turtle and RDF/XML), the service can be used to generate an <a href="http://www.w3.org/2001/sw/DataAccess/tests/earl">EARL implementation report</a>.</p>-->
<!--</section>-->

<!--<section>-->
<!--<h4><a name="graphstoreprotocoltests" id="graphstoreprotocoltests"/>Graph Store HTTP Protocol Tests</a></h4>-->

<!--<p>A number of test cases for the <a href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL 1.1 Graph Store HTTP Protocol</a> consisting of HTTP requests and expected responses are described in a <a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/http-rdf-update/">separate document</a>.</p>-->
<!--</section>-->

<!--<section>-->
  <!--<h4><a name="testannotations" id="testannotations"/>Test annotations</a></h4>-->

<!--<p>@@@ This section might need reconsideration to reflect extensions (like new library functions) that have become standard in SPARQL1.1 @@@</p>-->
  <!--<h5>mf:requires</h5>-->
  <!--<p>A number of tests in the open-world directory illustrate features of SPARQL-->
  <!--by depending on how a SPARQL query processor can extend the set of core types-->
  <!--and operations as defined by the operator table [<a href="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping</a>].</p>-->
  <!--<p>These tests are marked by property <code>mf:requires</code> and an object value from one-->
  <!--of the URIs described below.</p>-->
  <!--<dl>-->
    <!--<dt><code>mf:XsdDateOperations</code></dt>-->
    <!--<dd>Requires the processor to understand comparisons of-->
    <!--literal of type xsd:date. Without providing operations on the xsd:date datatype, a-->
    <!--processor would raise an error&nbsp;on the operations of &quot;=&quot; and &quot;!=&quot;-->
    <!--etc. With-->
    <!--an understanding of xsd:date, a processor can perform value-based operations-->
    <!--and provide the operations described in &quot;XQuery 1.0 and XPath 2.0 Functions-->
    <!--and Operators&quot; (e.g. <a href="http://www.w3.org/TR/xpath-functions/">-->
    <!--date-equals</a> <a href="http://www.w3.org/TR/xpath-functions/">-->
    <!--date-less-than</a>)</dd>-->

	<!--<dt><code>mf:StringSimpleLiteralCmp</code></dt>-->
    <!--<dd>This indicates that the test uses the fact that plain literals, without-->
    <!--language tags test are the same value as an <code>xsd:string</code> with the same-->
    <!--lexicial form. This is covered by rules &quot;xsd 1a&quot; and &quot;xsd 1b&quot; from RDF-->
    <!--Semantics [<a href="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/#DtypeRules</a>].</dd>-->

    <!--<dt><code>mf:KnownTypesDefault2Neq</code></dt>-->
    <!--<dd>This indicates that a processor extends the SPARQL operator model by-->
    <!--using the fact that values of literals can be in disjoint value spaces and-->
    <!--hence can not be equal by value. For example, an xsd:integer can not be the-->
    <!--same value as an xsd:boolean because these two datatypes define disjoint-->
    <!--value spaces.</dd>-->

<!--<dt><code>mf:LangTagAwareness</code></dt>-->
	<!--<dd>This indicates that the test assumes the SPARQL query processor has support-->
<!--for plain literals with language tags.  The minimum set of operators in the-->
    <!--<a href="http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping">SPARQL operator table</a>-->
<!--does not include language tag handling, only plain literals without language-->
<!--tag (simple literals) and certain XSD datatypes.-->

<!--</dl>-->

    <!--<h5>mf:notable</h5>-->
  <!--<p>This annotation indicates a feature of SPARQL that implementers might note:</p>-->
  <!--<dl>-->
    <!--<dt><code>mf:IllFormedLiteral</code></dt>-->
    <!--<dd>The test involves handling of ill-formed literals.</dd>-->

<!--</dl>-->
<!--</section>-->

<section>
  <h4><a name="howto" id="howto"/>How to run the Test Cases</a></h4>


<!--<p><b>@@@ This section shall contain some hints on how to actually run the test suite and generate implementation reports for implementers.</b></p>-->

    <!--<p>-->


        <!--&nbsp;</p>-->
    <!--<div class="issue" id="issue-A">-->
        <!--<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">-->
            <!--<span>TODO B</span><span style="text-transform: none"></span>-->
        <!--</div>-->
        <!--<div class="">-->
            <!--<p>-->
                <!--Translate in English-->
            <!--</p>-->
        <!--</div>-->
    <!--</div>-->

    <section>
        <h5><a name="howto" id="howto"/>How to run the Test Cases in local with Docker</a></h5>
        This script calculates an indicator of interoperability for SPARQL 1.1 with the TFT framework (Test-For-Triplestore). Here, it is applied to the RDF Blazegraph database. These steps are: (1) upload the Docker images and (2) compile them, (3) deploy five nodes of Linked Data locally, (4) install TFT, (5) load the tests, (6) run the tests by saving the results and (7) calculate the interoperability indicator.

        <pre>
# (1) Upload the Docker images
docker pull bordercloud/tft-jena-fuseki
docker pull bordercloud/tft-virtuoso7-stable

# (2) Compile the Docker images of SPARQL service to test
docker build -t tft-stardog .

# (3) Deploy a Linked Data locally
# 172.17.0.2
docker run --privileged --name instance.tft-stardog -h tft-stardog -d tft-stardog
# 172.17.0.3
docker run --privileged --name instance.tft.example.org \
           -h example.org -d bordercloud/tft-virtuoso7-stable
# 172.17.0.4
docker run --privileged --name instance.tft.example1.org \
           -h example1.org -d bordercloud/tft-virtuoso7-stable
# 172.17.0.5
docker run --privileged --name instance.tft.example2.org \
           -h example2.org -d bordercloud/tft-virtuoso7-stable
# 172.17.0.6 local database to save tests and results
docker run --privileged --name instance.tft_database -d tft-jena-fuseki

# (4) Install TFT
git clone --recursive https://github.com/BorderCloud/TFT.git
cd TFT
# Install the SPARQL client of TFT
composer install

# (5) Load all the tests
php ./tft-testsuite -a -t fuseki -q http://172.17.0.6/test/query \
                    -u http://172.17.0.6/test/update

# (6) Execute these tests
php ./tft -t fuseki -q http://172.17.0.6/test/query \
                    -u http://172.17.0.6/test/update \
          -tt fuseki -tq http://172.17.0.2/blazegraph/namespace/test/sparql/ \
                     -tu http://172.17.0.2/blazegraph/namespace/test/sparql/ \
          -r http://example.org/buildid   \
          -o ./junit  \
          --softwareName="Jena" \
          --softwareDescribeTag=X.X.X \
          --softwareDescribe="Name"

# (7) Calculate a score/indicator of interoperability
php ./tft-score -t fuseki -q http://172.17.0.6/test/query \
                          -u http://172.17.0.6/test/update \
                -r  http://example.org/buildid
    </pre>
    </section>

    <section>
        <h5><a name="howto" id="howto"/>How to run the Test Cases in GitHub via Travis CI</a></h5>

        https://github.com/BorderCloud/tft-jena-fuseki/blob/master/.travis.yml
        <pre>
sudo: required
# notifications:
#   email:
#     recipients:
#      - yourEmail@example.com
#     on_success: always # default: change (other : never)
#     on_failure: always # default: always

env:
  global:
    - URI="https://travis-ci.org/BorderCloud/tft-blazegraph/builds/$((TRAVIS_JOB_ID - 1))"
    - NAME="Blazegraph"
    - VERSION="v2.2.0"
#    - SPARQLSCORE_DATABASE="134.158.74.247"
    - SPARQLSCORE_DATABASE="172.17.0.6" #local

language: php
php:
  - '7.1'

services:
  - docker

before_install:
# Download docker's images
  - docker pull bordercloud/tft-jena-fuseki
  - docker pull bordercloud/tft-virtuoso7-stable

# Compile the docker's project
  - docker build -t tft-blazegraph .

script:
# Deploy TFT

# 172.17.0.2
  -   docker run --privileged --name instance.tft-blazegraph -h tft-blazegraph -d tft-blazegraph
# 172.17.0.3
  -   docker run --privileged --name instance.tft.example.org -h example.org -d bordercloud/tft-virtuoso7-stable
# 172.17.0.4
  -   docker run --privileged --name instance.tft.example1.org -h example1.org -d bordercloud/tft-virtuoso7-stable
# 172.17.0.5
  -   docker run --privileged --name instance.tft.example2.org -h example2.org -d bordercloud/tft-virtuoso7-stable

# Run RDF database in order to save tests and results in local (decomment these line and change the variable SPARQLSCORE_DATABASE
## 172.17.0.6 for local
  -   docker run --privileged --name instance.tft_database -d bordercloud/tft-jena-fuseki

# Wait...
  -   sleep 30
#  -   docker network inspect bridge

  -   git clone --recursive https://github.com/BorderCloud/TFT.git
  -   cd TFT
  -   composer install
  -   php ./tft-testsuite -a -t fuseki -q http://${SPARQLSCORE_DATABASE}/test/query -u http://${SPARQLSCORE_DATABASE}/test/update
  -   php ./tft -t fuseki -q http://${SPARQLSCORE_DATABASE}/test/query -u http://${SPARQLSCORE_DATABASE}/test/update -tt fuseki -tq http://172.17.0.2/blazegraph/namespace/test/sparql/ -tu http://172.17.0.2/blazegraph/namespace/test/sparql/ -r ${URI} -o ./junit --softwareName="${NAME}" --softwareDescribeTag=${VERSION}  --softwareDescribe="${TRAVIS_COMMIT}"
  -   php ./tft-score -t fuseki -q http://${SPARQLSCORE_DATABASE}/test/query -u http://${SPARQLSCORE_DATABASE}/test/update -r  ${URI}

after_success:
#  - if [ "$TRAVIS_BRANCH" == "master" ]; then
#    docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD ;
#    docker push bordercloud/tft-blazegraph;
#    fi
        </pre>
    </section>


    <section>
        <h5><a name="howto" id="howto"/>Share the report</a></h5>

In the Travis script, you can replace the local IP by the IP of a SPARQL service online, such as, SPARQLScore (134.158.74.247).
    </section>
</section>



	<section>
		<h2>Reports</h2>
		<p>
			This section summarizes the outcomes of last test reports of SPARQL implementation in docker images hosted by GitHub. List of Docker images used:
                <ul>
                    <li><a href="https://github.com/BorderCloud/tft-blazegraph">Blazegraph 2.2.0</a></li>
                    <li><a href="https://github.com/BorderCloud/tft-jena-fuseki">Jena-Fuseki 3.8.0</a></li>
                    <li><a href="https://github.com/BorderCloud/tft-stardog">Stardog community 5.3.3</a></li>
                    <li><a href="https://github.com/BorderCloud/tft-virtuoso7-stable">OpenLink Virtuoso version community 7/stable</a></li>
                </ul>
		</p>
        <section>
            <h3>Implementation by specification</h3>
            <div id="result2"
                 data-sgvizler-endpoint="http://134.158.74.247/test/query"
                 data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT ?nb ?Specification ?Nb_tests ?Implemented
(concat(xsd:string(round((?Implemented / ?Nb_tests)* 100)),&quot;%&quot;) as ?Percent)
WHERE {
  SELECT   ?nb ?Specification
  (COUNT(?testiri) as ?Nb_tests)
  (SUM(?Is_implemented) as ?Implemented)

  WHERE {


    SELECT DISTINCT ?nb ?Specification ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

(
    IF(
   (?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ) ||
  (?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph )  ||
  (?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog )  ||
  (?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso )
    , 1, 0 )
                as ?Is_implemented)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {
               ( 1 &lt;http://www.w3.org/TR/sparql11-query/&gt; )
               ( 2 &lt;http://www.w3.org/TR/sparql11-update/&gt;)
               ( 3 &lt;http://www.w3.org/TR/sparql11-results-csv-tsv/&gt; )
               ( 4 &lt;http://www.w3.org/TR/sparql11-results-json/&gt;)
               ( 5 &lt;http://www.w3.org/TR/sparql11-federated-query/&gt;)
               ( 6 &lt;http://www.w3.org/TR/sparql11-entailment/&gt; )
               ( 7 &lt;http://www.w3.org/TR/sparql11-service-description/&gt;)
               ( 8 &lt;http://www.w3.org/TR/sparql11-protocol/&gt;)
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?nb ?Specification ?testiri ?Test  ?Approval
    #ORDER BY ?Test

 }  GROUP BY ?nb ?Specification
} ORDER BY ?nb
"
                 data-sgvizler-chart='sgvizler.visualization.Table'
                 data-sgvizler-chart-options=''
                 data-sgvizler-endpoint_output_format='json'
                 data-sgvizler-log='2'
                 style='width:100%;'  ></div>
        </section>
        <section>
                <h3>Implementation by software</h3>


        <div id="result"
             data-sgvizler-endpoint="http://134.158.74.247/test/query"
             data-sgvizler-query="prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT ?nb  ?Specification
(COUNT(DISTINCT ?test) as ?Nb_Tests)
(CONCAT(xsd:string(round((?Nb_Tests - COUNT(DISTINCT ?testKOJena))*100/ ?Nb_Tests)),&quot;%&quot;) as ?Jena)
(CONCAT(xsd:string(round((?Nb_Tests - COUNT(DISTINCT ?testKOBlazegraph))*100/ ?Nb_Tests)),&quot;%&quot;) as ?Blazegraph)
(CONCAT(xsd:string(round((?Nb_Tests - COUNT(DISTINCT ?testKOStardog))*100/ ?Nb_Tests)),&quot;%&quot;) as ?Stardog)
(CONCAT(xsd:string(round((?Nb_Tests - COUNT(DISTINCT ?testKOVirtuoso))*100/ ?Nb_Tests)),&quot;%&quot;) as ?Virtuoso)

WHERE
{
      VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
           (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
           )
        }

    GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
      VALUES (?nb ?categoryIRI)  {
           ( 1 &lt;http://www.w3.org/TR/sparql11-query/&gt; )
           ( 2 &lt;http://www.w3.org/TR/sparql11-update/&gt;)
           ( 3 &lt;http://www.w3.org/TR/sparql11-results-csv-tsv/&gt; )
           ( 4 &lt;http://www.w3.org/TR/sparql11-results-json/&gt;)
           ( 5 &lt;http://www.w3.org/TR/sparql11-federated-query/&gt;)
           ( 6 &lt;http://www.w3.org/TR/sparql11-entailment/&gt; )
           ( 7 &lt;http://www.w3.org/TR/sparql11-service-description/&gt;)
           ( 8 &lt;http://www.w3.org/TR/sparql11-protocol/&gt;)
        }

      ?categoryIRI rdfs:label ?Specification ;
                     mf:conformanceRequirement ?list.
        ?list rdf:rest*/rdf:first ?ttlTests .
        ?ttlTests mf:entries ?entries .
       ?entries rdf:rest*/rdf:first ?test.

    }
    GRAPH ?gJena {
        ?assertionJena a earl:Assertion.
        ?assertionJena earl:test ?test.
        OPTIONAL{
        ?assertionJena earl:result ?resultJena.
        ?resultJena earl:outcome ?outJena .
        ?assertionJena earl:test ?testKOJena.
        FILTER ( ?outJena != earl:passed)
        }
    }
    GRAPH ?gBlazegraph {
        ?assertionBlazegraph a earl:Assertion.
        ?assertionBlazegraph earl:test ?test.
        OPTIONAL{
        ?assertionBlazegraph earl:result ?resultBlazegraph.
        ?resultBlazegraph earl:outcome ?outBlazegraph .
        ?assertionBlazegraph earl:test ?testKOBlazegraph.
        FILTER ( ?outBlazegraph != earl:passed)
        }
    }
    GRAPH ?gStardog {
        ?assertionStardog a earl:Assertion.
        ?assertionStardog earl:test ?test.
        OPTIONAL{
        ?assertionStardog earl:result ?resultStardog.
        ?resultStardog earl:outcome ?outStardog .
        ?assertionStardog earl:test ?testKOStardog.
        FILTER ( ?outStardog != earl:passed)
        }
    }
    GRAPH ?gVirtuoso {
        ?assertionVirtuoso a earl:Assertion.
        ?assertionVirtuoso earl:test ?test.
        OPTIONAL{
        ?assertionVirtuoso earl:result ?resultVirtuoso.
        ?resultVirtuoso earl:outcome ?outVirtuoso .
        ?assertionVirtuoso earl:test ?testKOVirtuoso.
        FILTER ( ?outVirtuoso != earl:passed)
        }
    }
}
GROUP BY ?nb  ?Specification
ORDER BY ?nb"
             data-sgvizler-chart='sgvizler.visualization.Table'
             data-sgvizler-chart-options=''
             data-sgvizler-endpoint_output_format='json'
             data-sgvizler-log='2'
             style='width:100%;'  ></div>

		<!--<div class="issue" id="issue-1">-->
			<!--<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">-->
				<!--<span>TODO 1</span><span style="text-transform: none"></span>-->
			<!--</div>-->


		<!--</div>-->

		<!--<div class="issue" id="issue-1">-->
			<!--<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">-->
				<!--<span>TODO 2</span><span style="text-transform: none"></span>-->
			<!--</div>-->
			<!--<div class="">-->
			  <!--<p>-->
			  <!--Faire la liste des erreurs pour ce logiciel coté syntaxe-->
			  <!--</p>-->
<!--<div id="result_GCA"-->
<!--data-sgvizler-query="PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;-->
<!--PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;-->
<!--PREFIX rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;-->

<!--SELECT  DISTINCT ?label-->
<!--WHERE {-->
<!--GRAPH ?g  {-->
        <!--?spec  mf:conformanceRequirement   ?collection .-->
        <!--?spec  rdfs:label   ?label .-->
        <!--?collection   rdf:rest*/rdf:first  ?manifest .-->
<!--}-->
<!--}"-->
<!--data-sgvizler-endpoint="http://134.158.74.247/test/query"-->
<!--data-sgvizler-chart="sgvizler.visualization.Table"-->
<!--data-sgvizler-log="2"-->
<!--data-sgvizler-method="GET"-->
<!--&gt;</div>-->
			<!--</div>-->
		<!--</div>-->

		 <!--<div id="requete2"-->
			 <!--data-sgvizler-query="PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;-->
	<!--PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;-->
	<!--prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;-->

	<!--SELECT  (?specLink as ?Specification)-->
	<!--WHERE {-->
	<!--GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt;  {-->
			<!--?spec  mf:conformanceRequirement   ?collection .-->
			<!--?spec  rdfs:label   ?label .-->
			<!--?collection 	rdf:rest*/rdf:first  ?manifest .-->
			<!--OPTIONAL{-->
		   <!--?manifest rdfs:label   ?manifestLabel .-->
		 <!--}-->

			 <!--BIND( concat('&lt;a href=\'',str(?manifest),'\'&gt;',IF(bound(?manifestLabel), ?manifestLabel, 'no label') ,'&lt;/a&gt;') as ?manifestLink)-->
		<!--BIND( concat('&lt;a href=\'',str(?spec),'\'&gt;',?label ,'&lt;/a&gt;') as ?specLink)-->
		<!--}-->
		<!--}-->
		<!--GROUP BY ?specLink-->
		<!--ORDER BY ?specLink"-->
		<!--data-sgvizler-endpoint="http://134.158.74.247/test/query"-->
		<!--data-sgvizler-chart="sgvizler.visualization.Table"-->
		<!--data-sgvizler-log="2"-->
		<!--data-sgvizler-method="POST"-->
    <!--&gt;</div>-->


		<!--<div class="issue" id="issue-1">-->
			<!--<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">-->
				<!--<span>TODO 3</span><span style="text-transform: none"></span>-->
			<!--</div>-->
			<!--<div class="">-->
			  <!--<p>-->
			  <!--Faire la liste des erreurs pour ce logiciel coté résultat-->
			  <!--</p>-->
			<!--</div>-->
		<!--</div>-->
        </section>
	</section>

  <section>
	<h2>Tests</h2>

   	<section>
      <h3>Tests by Specifications</h3>
      			<section>
				<h4>SPARQL 1.1 Query Language</h4>
                    <div id="sgvzl_example_query1"
                         data-sgvizler-endpoint="http://134.158.74.247/test/query"
                         data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT  ?Test  ?Approval
(IF(?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ,&quot;Passed&quot;,&quot;&quot;) as ?Jena )
(IF(?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph ,&quot;Passed&quot;,&quot;&quot;) as ?Blazegraph )
(IF(?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog ,&quot;Passed&quot;,&quot;&quot;) as ?Stardog )
(IF(?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso ,&quot;Passed&quot;,&quot;&quot;) as ?Virtuoso )

WHERE {
    SELECT DISTINCT ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {
               ( 1 &lt;http://www.w3.org/TR/sparql11-query/&gt; )
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?testiri ?Test  ?Approval
    ORDER BY ?Test
}
"
                         data-sgvizler-chart='sgvizler.visualization.Table'
                         data-sgvizler-chart-options=''
                         data-sgvizler-endpoint_output_format='json'
                         data-sgvizler-log='2'
                         style='width:100%;'  ></div>


			</section>
			<section>
				<h4>SPARQL 1.1 Update</h4>
				<p>

				</p>
                <div id="sgvzl_example_query2"
                     data-sgvizler-endpoint="http://134.158.74.247/test/query"
                     data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT  ?Test  ?Approval
(IF(?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ,&quot;Passed&quot;,&quot;&quot;) as ?Jena )
(IF(?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph ,&quot;Passed&quot;,&quot;&quot;) as ?Blazegraph )
(IF(?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog ,&quot;Passed&quot;,&quot;&quot;) as ?Stardog )
(IF(?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso ,&quot;Passed&quot;,&quot;&quot;) as ?Virtuoso )

WHERE {
    SELECT DISTINCT ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {
               ( 2 &lt;http://www.w3.org/TR/sparql11-update/&gt;)
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?testiri ?Test  ?Approval
    ORDER BY ?Test
}
"
                     data-sgvizler-chart='sgvizler.visualization.Table'
                     data-sgvizler-chart-options=''
                     data-sgvizler-endpoint_output_format='json'
                     data-sgvizler-log='2'
                     style='width:100%;'  ></div>
			</section>
			<section>
				<h4>SPARQL 1.1 Query Results CSV and TSV Formats</h4>
				<p>

				</p>
                <div id="sgvzl_example_query3"
                     data-sgvizler-endpoint="http://134.158.74.247/test/query"
                     data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT  ?Test  ?Approval
(IF(?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ,&quot;Passed&quot;,&quot;&quot;) as ?Jena )
(IF(?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph ,&quot;Passed&quot;,&quot;&quot;) as ?Blazegraph )
(IF(?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog ,&quot;Passed&quot;,&quot;&quot;) as ?Stardog )
(IF(?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso ,&quot;Passed&quot;,&quot;&quot;) as ?Virtuoso )

WHERE {
    SELECT DISTINCT ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {

                ( 3 &lt;http://www.w3.org/TR/sparql11-results-csv-tsv/&gt; )
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?testiri ?Test  ?Approval
    ORDER BY ?Test
}
"
                     data-sgvizler-chart='sgvizler.visualization.Table'
                     data-sgvizler-chart-options=''
                     data-sgvizler-endpoint_output_format='json'
                     data-sgvizler-log='2'
                     style='width:100%;'  ></div>

			</section>
			<section>
				<h4>SPARQL 1.1 Query Results JSON Format</h4>
				<p>

				</p>

                <div id="sgvzl_example_query4"
                     data-sgvizler-endpoint="http://134.158.74.247/test/query"
                     data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT  ?Test  ?Approval
(IF(?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ,&quot;Passed&quot;,&quot;&quot;) as ?Jena )
(IF(?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph ,&quot;Passed&quot;,&quot;&quot;) as ?Blazegraph )
(IF(?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog ,&quot;Passed&quot;,&quot;&quot;) as ?Stardog )
(IF(?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso ,&quot;Passed&quot;,&quot;&quot;) as ?Virtuoso )

WHERE {
    SELECT DISTINCT ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {
              ( 4 &lt;http://www.w3.org/TR/sparql11-results-json/&gt;)
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?testiri ?Test  ?Approval
    ORDER BY ?Test
}
"
                     data-sgvizler-chart='sgvizler.visualization.Table'
                     data-sgvizler-chart-options=''
                     data-sgvizler-endpoint_output_format='json'
                     data-sgvizler-log='2'
                     style='width:100%;'  ></div>
			</section>
			<section>
				<h4>SPARQL 1.1 Federation Extensions</h4>
				<p>

				</p>

                <div id="sgvzl_example_query5"
                     data-sgvizler-endpoint="http://134.158.74.247/test/query"
                     data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT  ?Test  ?Approval
(IF(?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ,&quot;Passed&quot;,&quot;&quot;) as ?Jena )
(IF(?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph ,&quot;Passed&quot;,&quot;&quot;) as ?Blazegraph )
(IF(?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog ,&quot;Passed&quot;,&quot;&quot;) as ?Stardog )
(IF(?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso ,&quot;Passed&quot;,&quot;&quot;) as ?Virtuoso )

WHERE {
    SELECT DISTINCT ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {
               ( 5 &lt;http://www.w3.org/TR/sparql11-federated-query/&gt;)
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?testiri ?Test  ?Approval
    ORDER BY ?Test
}
"
                     data-sgvizler-chart='sgvizler.visualization.Table'
                     data-sgvizler-chart-options=''
                     data-sgvizler-endpoint_output_format='json'
                     data-sgvizler-log='2'
                     style='width:100%;'  ></div>
			</section>
			<section>
				<h4>SPARQL 1.1 Entailment Regimes</h4>
				<p>

				</p>

                <div id="sgvzl_example_query6"
                     data-sgvizler-endpoint="http://134.158.74.247/test/query"
                     data-sgvizler-query="PREFIX dawgt: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt;
prefix earl: &lt;http://www.w3.org/ns/earl#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
prefix mf:  &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;

SELECT  ?Test  ?Approval
(IF(?assertionCountJena &gt; 0 &amp;&amp; ?assertionCountJena = ?assertionCountKOJena ,&quot;Passed&quot;,&quot;&quot;) as ?Jena )
(IF(?assertionCountBlazegraph &gt; 0 &amp;&amp; ?assertionCountBlazegraph = ?assertionCountKOBlazegraph ,&quot;Passed&quot;,&quot;&quot;) as ?Blazegraph )
(IF(?assertionCountStardog &gt; 0 &amp;&amp; ?assertionCountStardog = ?assertionCountKOStardog ,&quot;Passed&quot;,&quot;&quot;) as ?Stardog )
(IF(?assertionCountVirtuoso &gt; 0 &amp;&amp; ?assertionCountVirtuoso = ?assertionCountKOVirtuoso ,&quot;Passed&quot;,&quot;&quot;) as ?Virtuoso )

WHERE {
    SELECT DISTINCT ?testiri ?Test  ?Approval
    (COUNT(?assertionJena) as ?assertionCountJena)
    (COUNT(?outJena) as ?assertionCountKOJena)

    (COUNT(?assertionBlazegraph) as ?assertionCountBlazegraph)
    (COUNT(?outBlazegraph) as ?assertionCountKOBlazegraph)

    (COUNT(?assertionStardog) as ?assertionCountStardog)
    (COUNT(?outStardog) as ?assertionCountKOStardog)

    (COUNT(?assertionVirtuoso) as ?assertionCountVirtuoso)
    (COUNT(?outVirtuoso) as ?assertionCountKOVirtuoso)

    WHERE
    {
          VALUES (?gJena ?gBlazegraph ?gStardog ?gVirtuoso)  {
               (
&lt;https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/413621870&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-blazegraph/builds/413657744&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-stardog/builds/413648307&gt;
               &lt;https://travis-ci.org/BorderCloud/tft-virtuoso7-stable/builds/413632299&gt;
               )
            }

        GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt; {
          VALUES (?nb ?categoryIRI)  {
               ( 6 &lt;http://www.w3.org/TR/sparql11-entailment/&gt; )
            }

          ?categoryIRI rdfs:label ?Specification ;
                         mf:conformanceRequirement ?list.
          ?list rdf:rest*/rdf:first ?ttlTests .
          ?ttlTests mf:entries ?entries .
          ?entries rdf:rest*/rdf:first ?testiri.

                ?testiri mf:name        ?Test ;
                     dawgt:approval ?approvaliri .

              BIND( IF(?approvaliri = dawgt:Approved , &quot;Approved&quot;, &quot;&quot;) as ?Approval)
        }
        GRAPH ?gJena {
            ?assertionJena a earl:Assertion.
            ?assertionJena earl:test ?testiri.
            OPTIONAL{
            ?assertionJena earl:result ?resultJena.
            ?resultJena earl:outcome ?outJena .
            FILTER ( ?outJena = earl:passed)
            }
        }
        GRAPH ?gBlazegraph {
            ?assertionBlazegraph a earl:Assertion.
            ?assertionBlazegraph earl:test ?testiri.
            OPTIONAL{
            ?assertionBlazegraph earl:result ?resultBlazegraph.
            ?resultBlazegraph earl:outcome ?outBlazegraph .
            FILTER ( ?outBlazegraph = earl:passed)
            }
        }
        GRAPH ?gStardog {
            ?assertionStardog a earl:Assertion.
            ?assertionStardog earl:test ?testiri.
            OPTIONAL{
            ?assertionStardog earl:result ?resultStardog.
            ?resultStardog earl:outcome ?outStardog .
            FILTER ( ?outStardog = earl:passed)
            }
        }
        GRAPH ?gVirtuoso {
            ?assertionVirtuoso a earl:Assertion.
            ?assertionVirtuoso earl:test ?testiri.
            OPTIONAL{
            ?assertionVirtuoso earl:result ?resultVirtuoso.
            ?resultVirtuoso earl:outcome ?outVirtuoso .
            FILTER ( ?outVirtuoso = earl:passed)
            }
        }
    }
    GROUP BY ?testiri ?Test  ?Approval
    ORDER BY ?Test
}
"
                     data-sgvizler-chart='sgvizler.visualization.Table'
                     data-sgvizler-chart-options=''
                     data-sgvizler-endpoint_output_format='json'
                     data-sgvizler-log='2'
                     style='width:100%;'  ></div>
			</section>
			<section>
				<h4>SPARQL 1.1 Service Description</h4>
				<p>

				</p>

                <div class="issue" >
                    <div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
                        <span>TODO  </span><span style="text-transform: none"></span>
                    </div>
                    <div class="">
                        <p>
                            Example :  http://w3c.github.io/rdf-tests/sparql11/reports/
                        </p>
                    </div>
                </div>
			</section>
			<section>
				<h4>SPARQL 1.1 Protocol</h4>
				<p>

				</p>

				<div class="issue" >
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO  </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  Example :  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Graph Store HTTP Protocol</h4>
				<p>

				</p>

                <div class="issue" >
                    <div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
                        <span>TODO  </span><span style="text-transform: none"></span>
                    </div>
                    <div class="">
                        <p>
                            Example :  http://w3c.github.io/rdf-tests/sparql11/reports/
                        </p>
                    </div>
                </div>
			</section>
		</section>
	</section>
</section>

<section class="appendix" id="issue-summary">
  <!-- A list of issues will magically appear here -->
</section>


    <script src="node_modules/jquery/dist/jquery.slim.js"></script>
    <script src="node_modules/sgvizler2/build/browser/sgvizler2.js"></script>
    <script>

            sgvizler2.containerDrawAll();
    </script>
    <script
            src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
    <script>
        alert("To display this page correctly, you must allow your browser to load unsafe scripts.");
    </script>

    <!-- Place this tag in your head or just before your close body tag. -->
  </body>
</html>
