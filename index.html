<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>SPARQL 1.1 Test Suite Report by TFT</title>


    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [
		{
		  name: "Karima Rafes",
                    url:        "http://karimarafes.me/",
                    company:    "BorderCloud",
                    companyURL: "http://bordercloud.com"
		},
		{
		  name: "Axel Polleres",
                    company: "Siemens AG"
		},
		{
		  name: "Steve Harris",
                  company: "IAM Research Group, Southampton"
		},
		{
		  name: "Jeen Broekstra",
                  company: "Information Systems Group, Eindhoven University of Technology"
		},
		{
		  name: "Lee Feigenbaum",
                  company: "Cambridge Semantics"
		}
		 ],
        processVersion: 2017,
        edDraftURI: "https://github.com/BorderCloud/tft-reports",
        shortName: "tft-reports",
	previousURI: "https://w3c.github.io/rdf-tests/sparql11/",
          lint: false
      };
    </script>
  </head>
  <body>

	<section id='abstract'><h2 id="abstract-0">Abstract</h2>
		<p>
			This document defines the format of the tests in the SPARQL test suite and lists
			test results from docker instances of RDF databases on GitHub that have evaluated by the tool TFT via Travis CI.
		</p>
	</section>

    <section id="sotd" class="introductory"><h2 id="status-of-this-document">Status of This Document</h2>
      <p>
        This document is merely a <abbr title="World Wide Web Consortium">W3C</abbr>-internal  document. It
        has no official standing of any kind and does not represent consensus of the <abbr title="World Wide Web Consortium">W3C</abbr>
        Membership.
      </p>
  </section>

	<section>
		<h2>Namespace prefixes</h2>
		<p>
			In this document we will employ the following namespace prefixes:
		</p>

		<dl>
			<dt><code>earl</code></dt>
			<dd><code><a href="http://www.w3.org/ns/earl#">http://www.w3.org/ns/earl#</a></code></dd>
		</dl>

	</section>

<section>
	<h2>Test Cases Format and Process</h2>

  	<div class="issue" id="issue-A">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO A</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  changer cette partie
			  </p>
			</div>
		</div>
  <p>


<section>
The
<a href="http://www.w3.org/2009/sparql/wiki/">SPARQL Working Group</a> uses a test-driven process.&nbsp; The <a href="http://www.w3.org/2009/sparql/docs/tests">test area</a> is a
collection of the current test cases of the working group extending and updating the <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">testcases</a> of the <a href="http://www.w3.org/2001/sw/DataAccess/">Data Access Working Group</a>. </p>
  <p>
Tests are divided into collections (corresponding to directories) for manageability.&nbsp; Each collection
of tests has a <em>manifest file</em> within its directory (usually named
<tt>manifest.ttl</tt>, but sometimes <tt>manifest.n3</tt>).
There is also a number of overall manifests containing entries pointing to the
individual test collection manifests:</p>

    <!--old version
<ul>
<li><a
href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/manifest-syntax.ttl">manifest
of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL1.0 Query Language</a></li>
<a
href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/manifest-evaluation.ttl">manifest
of query-evaluation tests</a> for the <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL1.0 Query Language</a>.</li>
<li><a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-query-syntax.ttl">manifest of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query Language</a></li>
  <li><a
href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-query-evaluation.ttl">manifest of query evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query Language</a></li>
  <li><a
href="data-sparql11/entailment/manifest.ttl">manifest of entailment evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL1.1 Entailment Regimes</a></li>
  <li><a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-update-syntax.ttl">manifest of syntax-only tests</a> (positive and negative tests) for the <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update Language</a></li>
  <li><a
href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/manifest-sparql11-update-syntax.ttl">manifest of update evaluation tests</a> for the <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update Language</a></li>
  <li><a
href="data-sparql11/service-description/manifest.ttl">manifest of service description tests</a> for the <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL1.1 Service Description</a></li>
</ul>
-->
    <div id="resulth"
         data-sgvizler-query="PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

SELECT  (?specLink as ?Specification)   (group_concat(?manifestLink) as ?Manifests)
WHERE {
GRAPH &lt;http://w3c.github.io/rdf-tests/sparql11/data-sparql11/&gt;  {
        ?spec  mf:conformanceRequirement   ?collection .
        ?spec  rdfs:label   ?label .
        ?collection 	rdf:rest*/rdf:first  ?manifest .
        OPTIONAL{
       ?manifest rdfs:label   ?manifestLabel .
     }

         BIND( concat('&lt;a href=\'',str(?manifest),'\'&gt;',IF(bound(?manifestLabel), ?manifestLabel, 'no label') ,'&lt;/a&gt;') as ?manifestLink)
    BIND( concat('&lt;a href=\'',str(?spec),'\'&gt;',?label ,'&lt;/a&gt;') as ?specLink)
    }
    }
    GROUP BY ?specLink
    ORDER BY ?specLink"
    data-sgvizler-endpoint="http://134.158.74.247/test/query"
    data-sgvizler-chart="sgvizler.visualization.Table"
    data-sgvizler-log="2"
    data-sgvizler-method="POST"
    ></div>

</section>

<section>
<h4><a name="organization" id="organization"/>Organization</a></h4>
<p>
The test cases are organised in two directories</p>
<ul>
  <li>The <a href="http://www.w3.org/2009/sparql/docs/tests/data-r2/">data-r2</a> directory holds the testcases from the previous <a href="http://www.w3.org/2001/sw/DataAccess/tests/r2">testcases</a>SPARQL1.0 Query language test suite @@@plus new tests that are restricted to SPARQL 1.0 features only??? @@@.</li>
  <li>The <a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11">data-sparql11</a> directory holds test cases aimed at covering as much of the SPARQL 1.1 Query Language and SPARQL 1.1 Update Language as possible.</li>
</ul>
  The purpose is to provide an up-to-date, upwards-compatible, consistent, and easy-to-use suite of test cases that SPARQL 1.1 implementors can use to evaluate and report on their
implementation.
</p>
<p>
The tests as-is shall constitute a test suite that the group will
use to generate an implementation report for the SPARQL1.1 Query  and SPARQL1.1 Update languages.</p>
<p><b>@@@ What about other tests, will we use the same structure for e.g. http-update, service-description tests, will we (a) have separate manifest(s) for entailment?</b></p>
</p>
</section>

<section>
  <h4><a name="vocabularies" id="vocabularies"/>Manifest Vocabularies</a></h4>

  <p>The SPARQL1.1 test manifest files define five vocabularies to express
  tests and results:</p>

  <ol>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-manifest.n3">manifest vocabulary</a> (prefixed with
    <tt>mf:</tt> below)</li>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-query.n3">query evaluation test vocabulary</a> (prefixed
    with <tt>qt:</tt> below)</li>
    <li><a href="test-update.n3">update evaluation test vocabulary</a> (prefixed
    with <tt>ut:</tt> below)</li>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-dawg.n3">DAWG test approval vocabulary</a> (prefixed
    with <tt>dawgt:</tt> below)</li>
    <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/test-dawg.n3">DAWG result-set RDF vocabulary</a> (prefixed
    with <tt>rs:</tt> below)</li>
  </ol>

  <p>All examples below use these prefix bindings (specified in <a
  href="http://www.w3.org/2001/sw/DataAccess/df1/">turtle</a>):</p>

  <pre class="diag">@prefix rdf:     &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs:    &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix mf:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt; .
@prefix dawgt:   &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-dawg#&gt; .
@prefix qt:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-query#&gt; .
@prefix ut:      &lt;http://www.w3.org/2009/sparql/tests/test-update#&gt; .
@prefix sd:      &lt;http://www.w3.org/ns/sparql-service-description#&gt; .
@prefix ent:     &lt;http://www.w3.org/ns/entailment/RDF&gt; .
@prefix rs:      &lt;http://www.w3.org/2001/sw/DataAccess/tests/result-set#&gt; .
  </pre>

  <h4><a name="structure" id="structure"/>Manifest Structure</a></h4>

  <p>
A manifest is a list (RDF Collection) of tests. Every test has
a name (<tt>mf:name</tt>); many tests also have a comment
(<tt>rdfs:comment</tt>) explaining the purpose of the test.
The <tt>dawgt:approval</tt> predicate relates a test to its official
Working Group status (e.g. <tt>dawgt:Approved</tt>).
Tests are grouped (via their <tt>rdf:type</tt>) as:
</p>

<ul>
	<li>positive SPARQL 1.0 Query syntax tests (<tt>mf:PositiveSyntaxTest</tt>)</li>
	<li>positive SPARQL 1.1 Query syntax tests (<tt>mf:PositiveSyntaxTest11</tt>)</li>
	<li>positive SPARQL 1.1 Update syntax tests (<tt>mf:PositiveUpdateSyntaxTest11</tt>)</li>
	<li>negative SPARQL 1.0 Query syntax tests (<tt>mf:NegativeSyntaxTest</tt>)</li>
	<li>negative SPARQL 1.1 Query syntax tests (<tt>mf:NegativeSyntaxTest11</tt>)</li>
	<li>negative SPARQL 1.1 Update syntax tests (<tt>mf:NegativeUpdateSyntaxTest11</tt>)</li>
	<li>SPARQL 1.0 and 1.1 Query evaluation tests (<tt>mf:QueryEvaluationTest</tt>)</li>
	<li>SPARQL 1.1 Update evaluation tests (<tt>mf:UpdateEvaluationTest</tt>)</li>
	<li>CSV Result Format tests (<tt>mf:CSVResultFormatTest</tt>)</li>
	<li>SPARQL 1.1 Service Description tests (<tt>mf:ServiceDescriptionTest</tt>)</li>
</ul>
</section>

<section>
  <h4><a name="filenames" id="filenames"/>File Names</a></h4>

 <p>Typically, in the test case suite, we use the following suffixes to indicate different file types:</p>
 <ul>
    <li><b>.ttl</b> ... Files describing RDF graphs in <a href="http://www.w3.org/TeamSubmission/turtle/">Turtle</a> syntax.
    </li>
    <li><b>.rdf</b> ... Files describing RDF graphs in <a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> syntax.
    </li>
    <li><b>.rq</b> ... Files containing a <a href="http://www.w3.org/TR/sparql11-query/">SPARQL1.1 Query</a> request.
    </li>
    <li><b>.ru</b> ... Files containing a <a href="http://www.w3.org/TR/sparql11-update/">SPARQL1.1 Update</a> request.
    </li>
    <li><b>.srx</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a>.
    </li>
    <li><b>.srj</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON Format</a>.
    </li>
    <li><b>.csv</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results CSV (Comma Separated Values) Format</a>.
    </li>
    <li><b>.tsv</b> ... Files containing a query result in the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results TSV (Tab Separated Values) Format</a>.
    </li>
  </ul>
<p>@@@ Fix/check final URL for http://www.w3.org/TR/sparql11-results-json/!</p>

 <p>@@@ Will we update the SPARQL Query Results XML Format spec for SPARQL1.1?</p>
</section>

<section>
  <h4><a name="syntaxtests" id="syntaxtests"/>Syntax Tests</a></h4>

  <p>
Each syntax test has an <tt>mf:action</tt>, the object of which is a
resource identifying a (possible) query string. An example definition of a
syntax test is:
  </p>

<pre class="diag">
&lt;#syntax-basic-01&gt;  mf:name  "syntax-basic-01.rq" ;
     rdf:type   mf:PositiveSyntaxTest ;
     mf:action  &lt;syntax-basic-01.rq&gt; ;
     dawgt:approvedBy &lt;http://lists.w3.org/Archives/Public/public-rdf-dawg/2007JanMar/0047&gt; ;
     dawgt:approval dawgt:Approved .
</pre>

<p>
A SPARQL implementation passes a <tt>mf:PositiveSyntaxTest</tt> if it parses
the query string without error. A SPARQL implementation passes a
<tt>mf:NegativeSyntaxTest</tt> if it raises an error while attempting to parse
the query string.
</p>
</section>

<section>
  <h4><a name="queryevaltests" id="queryevaltests"/>Query Evaluation Tests</a></h4>

  <p>Each query evaluation test has an <tt>mf:action</tt> and an
  <tt>mf:result</tt>. The object of <tt>mf:action</tt> is a resource with
  properties taken from the query evaluation test vocabulary. At a minimum, a
  test's action includes  a <tt>qt:query</tt>
  relation and an optional <tt>qt:data</tt> relation. The <tt>qt:data</tt>
  predicate points to a URI that can be dereferenced to yield the
  default graph for the test. The <tt>qt:query</tt> prediate points to a
  URI that can be dereferenced to yield the query string for the test. Query evaluation tests may also use the <tt>qt:graphData</tt> predicate to indicate the named graph components of the test's RDF dataset.</p>

  <p>In case the query in the <tt>qt:query</tt> predicate contains  <tt>FROM</tt> and <tt>FROM NAMED</tt> clauses and no <tt>qt:data</tt> is present, the graphs comprising the test's RDF dataset are expected to be loaded by dereferencing the respective URIs of the <tt>FROM/FROM NAMED</tt> clauses.</p>

  <p>Query evaluation tests also contain an <tt>mf:result</tt> which points to
  a URI that can be dereferenced to yield the
  expected results of the test query. These results are expressed in one of
  several possible ways:</p>

  <ul>
    <li>The <a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query
    Results XML Format</a>. SELECT or ASK queries.</li>
    <li>The <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL Query
    Results JSON Format</a>. SELECT or ASK queries.</li>
    <li>The <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/#tsv">SPARQL Query
    Results TSV Format</a>. SELECT or ASK queries. (As for testing the <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/#csv">SPARQL Query
    Results CSV Format</a>, see the separate Section within this document on <a href="#csvtests">CSV Result Format Tests</a>).</li>
    <li>The <a href="http://www.w3.org/2001/sw/DataAccess/tests/result-set.n3">DAWG result-set RDF vocabulary</a>.
    SELECT or ASK queries.</li>
    <li><a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> or <a
    href="http://www.dajobe.org/2004/01/turtle/">Turtle</a>. CONSTRUCT queries.</li>
  </ul>

<p>A SPARQL implementation passes a query evaluation test if the graph
produced by evaluating the query against the RDF dataset (and encoding in the
DAWG result set vocabulary, if necessary) is
<a href="http://www.w3.org/TR/rdf-concepts/#section-graph-equality">equivalent</a> [RDF-CONCEPTS]
to the graph named in the result (after encoding in the DAWG result set
vocabulary, if necessary).  Note that, solution order only is considered relevant, if the result is expressed in the test suite in the DAWG result set vocabulary, with explicit <code>rs:index</code> triples; otherwise solution order is considered irrelevant for passing. Equivalence can be tested by
checking that the graphs are isomorphic and have identical IRI and
literal nodes. Note that testing whether two result sets are isomorphic is simpler than full graph isomorphism. Iterating over rows in one set, finding a match with the other set, removing this pair, then making sure all rows are accounted for, achieves the same effect. </p>

<p>Query evaluation tests that involve the <a href="http://www.w3.org/TR/rdf-sparql-query#modReduced">REDUCED</a> keyword have slightly different passing criteria. These tests are indicated in the manifest files with the <tt>mf:resultCardinality</tt> predicate with an object of <tt>mf:LaxCardinality</tt>. To pass such a test, the result set produced by a SPARQL implementation must contain each solution in the expected result set at least once and no more than the number of times that the solution occurs in the expected result set. (That is, the expected result set contains the solutions with cardinalities as they would be if the query did not contain REDUCED; to pass the test, an implementation must produce the correct results with cardinalities between one and the cardinlity in the expected result set.)</p>

<p>An example definition of a query evaluation test is:</p>

<pre class="diag">
&lt;#dawg-regex-002&gt; a mf:QueryEvaluationTest ;
      mf:name    "regex-query-002" ;
      dawgt:approval dawgt:Approved ;
      dawgt:approvedBy &lt;http://lists.w3.org/Archives/Public/public-rdf-dawg/2007AprJun/0029.html&gt; ;
      rdfs:comment
          "Case insensitive unanchored match test" ;
      mf:action
          [ qt:query  &lt;regex-query-002.rq&gt; ;
            qt:data   &lt;regex-data-01.n3&gt; ] ;
      mf:result  &lt;regex-result-002.n3&gt; .
</pre>
</section>

<section>
  <h4><a name="csvtests" id="csvtests"/>CSV Result Format Tests</a></h4>

  <p>
CSV Result Format tests are meant to test a SPARQL implementation's ability to serialize query results in the SPARQL 1.1 Query Results CSV Format.
This is a lossy format, however, and so cannot be tested in the same manner as the other result formats.
Care should be taken to ensure that results produced in the CSV format are compared properly to the expected result values.
In all other respects, CSV tests should be treated as <a href="#queryevaltests">query evaluation tests</a>.
  </p>

<p>An example result set in the CSV Format is:</p>
<pre class="diag">
s,p,o
http://example.org/s2,http://example.org/p2,2.2
</pre>

<p>Due to the lossy nature of the CSV format, the single expected result could match any of the following actual results:</p>

<ul>
	<table class="plain">
	<tr>
		<th>s</th>
		<th>p</th>
		<th>o</th>
	</tr>
	<tr>
		<td>&lt;http://example.org/s2&gt;</td>
		<td>&lt;http://example.org/p2&gt;</td>
		<td>"2.2"</td>
	</tr>
	<tr>
		<td>&lt;http://example.org/s2&gt;</td>
		<td>&lt;http://example.org/p2&gt;</td>
		<td>"2.2"^^xsd:string</td>
	</tr>
	<tr>
		<td>&lt;http://example.org/s2&gt;</td>
		<td>&lt;http://example.org/p2&gt;</td>
		<td>"2.2"^^xsd:decimal</td>
	</tr>
	</table>
</ul>



</section>

<section>
  <h4><a name="entailevaltests" id="entailevaltests"/>Entailment Evaluation Tests</a></h4>

<p>Entailment Evaluation tests are special query evaluation tests that additionally (slightly ab-)use the <tt>sd:entailmentRegime</tt> and, optionally, the <tt>sd:entailmentProfile</tt> properties from the <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL 1.1 Service Description<a> vocabulary to further specify the  object of the <tt>mf:action</tt> property, indicating the expected entailment regime for graphs in the dataset and, where applicable, which OWL profile that test satisfies.</p>

<p>A SPARQL implementation passes a query evaluation test if its
answers over any graphs in the dataset using the <tt>sd:entailmentRegime</tt>
property comply with the criteria formalised in the
<a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL 1.1 Entailment Regimes<a> document. Apart from that, passing tests is as defined for query evaluation tests.</p>

<p>An example definition of an entailment evaluation test for the RDF entailment regime is:</p>

<pre class="diag">
:rdf01 rdf:type mf:QueryEvaluationTest ;
    mf:name    "RDF inference test" ;
    dawgt:approval dawgt:NotClassified ;
    mf:action
         [ qt:query  &lt;rdf01.rq&gt; ;
           qt:data   &lt;rdf01.ttl&gt;
           sd:entailmentRegime ent:RDF ] ;
    mf:result  &lt;rdf01.srx&gt;
    .
 </pre>

<p>Instead of a single entailment regime, tests can also be marked with a list of regimes. In this case,
any of the entailment regimes can be used to run the test. Similarly, the supported OWL profiles can be given as a
list or as a single value:</p>

<pre class="diag">
    :sparqldl-10  rdf:type   mf:QueryEvaluationTest ;
         mf:name  "sparqldl-10.rq: undist vars test" ;
         mf:action
                [ qt:query  <sparqldl-10.rq> ;
                qt:data <data-07.ttl> ;
           sd:EntailmentProfile ( pr:DL pr:EL pr:Full ) ;
           sd:entailmentRegime ( ent:OWL-Direct ent:OWL-RDF-Based )  ] ;
         mf:result  <sparqldl-10.srx> .
</pre>

<p>Note that, strictly speaking, this use of the <tt>sd:entailmentRegime</tt></a> property - by its specified <a href="http://www.w3.org/TR/sparql11-service-description/#sd-entailmentRegime">domain</a> - makes the object of the <tt>mf:action</tt> attribute a member of the <tt>sd:NamedGraph</tt> class; the <tt>sd:NamedGraph</tt> class though has no meaning within the context of test cases, so this domain specification can be savely ignored.</p>

</section>

<section>
  <h4><a name="updateevaltests" id="updateevaltests"/>Update Evaluation Tests</a></h4>

  <p>Each update evaluation test has an <tt>mf:action</tt> and an
  <tt>mf:result</tt>. The object of <tt>mf:action</tt> for an Update evaluation test case is a resource with properties taken from the update evaluation test vocabularies.
  The latter is used among others to describe the graph store's state before and after the execution of an update.  At a minimum, a test's action includes a <tt>ut:request</tt> relation.</p>

<p>The optional <tt>ut:data</tt> and <tt>ut:graphData</tt> relations within the <tt>mf:action</tt> of an update test case point the status of the <a href="http://www.w3.org/TR/sparql11-update/#sec_graphStore">Graph Store</a> <i>prior</i> to the update execution described in terms of at most one <tt>ut:data</tt> property denoting the unnamed graph and optional <tt>ut:graphData</tt> properties denoting named graphs.
 The object of the <tt>ut:data</tt> property is a URI reference to an RDF graph, whereas the objects of the <tt>ut:graphData</tt> property indicate the named graph components of the Graph Store. Named graphs are described either - analogous to the <tt>qt:graphData</tt> property from the query test vocabulary - by explicit URI reference (in which case the graph name is supposed to correspong to the respective URI reference), or the object of the <tt>ut:graphData</tt> property may be a resource further described in terms of an <tt>ut:graph</tt> and an <tt>rdfs:label</tt> property. Here, the <tt>ut:graph</tt> property is a URI reference to an RDF graph, whereas the <tt>rdfs:label</tt> property with plain literal value indicates the graph's name under which it is accessible in the graph store. The ability to assign a "name" different from the URI reference name explicitly to a named graph in a graph store is needed to denote different graphs by the same name to describe the status of a named graph prior and after execution of an update.</p>

<p>In the case of absence of both <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within the <tt>mf:action</tt>, the graph store is supposed to be empty (i.e., with an empty default graph and no named graphs) prior to execution of the update.
</p>

<p>
The
  <tt>ut:request</tt> predicate points to a URI that can be dereferenced to yield
  the update query string for the test.</p>

  <p>Update evaluation tests also contain an <tt>mf:result</tt>. The object of <tt>mf:result</tt> is a resource described in terms of the <tt>ut:data</tt> and <tt>ut:graphData</tt> properties. The optional <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within a an update evaluation test result denote the state of the graphstore <i>after</i> execution of the query analogous to the  <tt>ut:data</tt> and <tt>ut:graphData</tt> properties occurring in the <tt>mf:action</tt> of an update evaluation test.
In the case of absence of both <tt>ut:data</tt> and <tt>ut:graphData</tt> properties within the <tt>mf:result</tt>, the graph store is supposed to be empty after execution of the update.
</p>

<p>A SPARQL implementation passes a update evaluation test if the graphs in the graph store are
<a href="http://www.w3.org/TR/rdf-concepts/#section-graph-equality">equivalent</a> [RDF-CONCEPTS]
to the graphs denoted in the <tt>mf:action</tt> (and <tt>mf:result</tt>) property, respectively) prior to the update execution (after update execution, respectively). Equivalence can be tested as described above for query evaluation tests.</p>

<p>An example definition of an update evaluation test is:</p>

<pre class="diag">
:insert-data-spo1 a mf:UpdateEvaluationTest ;
    mf:name    "Simple insert data 1" ;
    rdfs:comment "This is a simple insert of a single triple to the unnamed graph of an empty graph store" ;
    dawgt:approval dawgt:NotClassified ;
    mf:action [
                ut:request &lt;insert-data-spo1.ru&gt; ;
                ut:data &lt;empty.ttl&gt;
              ] ;
    mf:result [
                ut:data  &lt;spo.ttl&gt;
              ] .
</pre>
</section>

<section>
<h4><a name="servicetests" id="servicetests"/>Federated Query Tests</a></h4>

<p>In SPARQL 1.1 Federated Query, tests cases contain new vocabulary not used before. These tests check whether the queries with that operator are correct or not. Queries using the <code>SERVICE</code> keyword for accessing remote SPARQL endpoints need a way to describe the data comming from these endpoints which was not previously defined.</p>

<p>The predicate <code>qt:serviceData</code> helps to describe the data comming from these remote SPARQL endpoints in a query. This predicate can also contain the predicate <code>qt:endpoint</code> which contains the URL of the remote SPARQL endpoint.</p>

<p>An example definition of a Federated Query test is:</p>

<pre class="diag">
:service1 rdf:type mf:QueryEvaluationTest ;
       mf:name    "SERVICE test 1" ;
       dawgt:approval dawgt:NotClassified ;
       mf:feature sd:BasicFederatedQuery ;
       mf:action [
               qt:query  &lt;service01.rq&gt; ;
               qt:data   &lt;data01.ttl&gt; ;
               qt:serviceData [
                       qt:endpoint &lt;http://example.org/sparql&gt; ;
                       qt:data     &lt;data01endpoint.ttl&gt;
               ]
       ] ;
       mf:result  &lt;service01.srx&gt; .</pre>


</section>

<section>
<h4><a name="protocoltests" id="protocoltests"/>Protocol Tests</a></h4>

<p>A testing service for <a href="http://www.w3.org/TR/sparql11-protocol/">SPARQL 1.1 Protocol</a> implementations has been set up at <tt><a href="http://www.w3.org/2009/sparql/protocol_validator">http://www.w3.org/2009/sparql/protocol_validator</a></tt>. The service and tests performed by this service are described in a <a href="https://github.com/kasei/sparql11-protocolvalidator">separate document</a>.</p>
</section>

<section>
<h4><a name="servicedescriptiontests" id="servicedescriptiontests"/>Service Description Tests</a></h4>

<p>A testing service for SPARQL 1.1 Protocol implementations supporting <a href="http://www.w3.org/TR/sparql11-service-description/">SPARQL 1.1 Service Descriptions</a> has been set up at <tt><a href="http://www.w3.org/2009/sparql/sdvalidator">http://www.w3.org/2009/sparql/sdvalidator</a></tt>. The service performs a number of tests to verify that a submitted endpoint returns RDF that conforms to the service description vocabulary specification. Using content negotiation to request RDF (supporting both Turtle and RDF/XML), the service can be used to generate an <a href="http://www.w3.org/2001/sw/DataAccess/tests/earl">EARL implementation report</a>.</p>
</section>

<section>
<h4><a name="graphstoreprotocoltests" id="graphstoreprotocoltests"/>Graph Store HTTP Protocol Tests</a></h4>

<p>A number of test cases for the <a href="http://www.w3.org/TR/sparql11-http-rdf-update/">SPARQL 1.1 Graph Store HTTP Protocol</a> consisting of HTTP requests and expected responses are described in a <a href="http://www.w3.org/2009/sparql/docs/tests/data-sparql11/http-rdf-update/">separate document</a>.</p>
</section>

<section>
  <h4><a name="testannotations" id="testannotations"/>Test annotations</a></h4>

<p>@@@ This section might need reconsideration to reflect extensions (like new library functions) that have become standard in SPARQL1.1 @@@</p>
  <h5>mf:requires</h5>
  <p>A number of tests in the open-world directory illustrate features of SPARQL
  by depending on how a SPARQL query processor can extend the set of core types
  and operations as defined by the operator table [<a href="http://www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping</a>].</p>
  <p>These tests are marked by property <code>mf:requires</code> and an object value from one
  of the URIs described below.</p>
  <dl>
    <dt><code>mf:XsdDateOperations</code></dt>
    <dd>Requires the processor to understand comparisons of
    literal of type xsd:date. Without providing operations on the xsd:date datatype, a
    processor would raise an error&nbsp;on the operations of &quot;=&quot; and &quot;!=&quot;
    etc. With
    an understanding of xsd:date, a processor can perform value-based operations
    and provide the operations described in &quot;XQuery 1.0 and XPath 2.0 Functions
    and Operators&quot; (e.g. <a href="http://www.w3.org/TR/xpath-functions/">
    date-equals</a> <a href="http://www.w3.org/TR/xpath-functions/">
    date-less-than</a>)</dd>

	<dt><code>mf:StringSimpleLiteralCmp</code></dt>
    <dd>This indicates that the test uses the fact that plain literals, without
    language tags test are the same value as an <code>xsd:string</code> with the same
    lexicial form. This is covered by rules &quot;xsd 1a&quot; and &quot;xsd 1b&quot; from RDF
    Semantics [<a href="http://www.w3.org/TR/rdf-mt/">http://www.w3.org/TR/rdf-mt/#DtypeRules</a>].</dd>

    <dt><code>mf:KnownTypesDefault2Neq</code></dt>
    <dd>This indicates that a processor extends the SPARQL operator model by
    using the fact that values of literals can be in disjoint value spaces and
    hence can not be equal by value. For example, an xsd:integer can not be the
    same value as an xsd:boolean because these two datatypes define disjoint
    value spaces.</dd>

<dt><code>mf:LangTagAwareness</code></dt>
	<dd>This indicates that the test assumes the SPARQL query processor has support
for plain literals with language tags.  The minimum set of operators in the
    <a href="http://www.w3.org/TR/rdf-sparql-query/#OperatorMapping">SPARQL operator table</a>
does not include language tag handling, only plain literals without language
tag (simple literals) and certain XSD datatypes.

</dl>

    <h5>mf:notable</h5>
  <p>This annotation indicates a feature of SPARQL that implementers might note:</p>
  <dl>
    <dt><code>mf:IllFormedLiteral</code></dt>
    <dd>The test involves handling of ill-formed literals.</dd>

</dl>
</section>

<section>
  <h4><a name="howto" id="howto"/>How to run the Test Cases</a></h4>


<p><b>@@@ This section shall contain some hints on how to actually run the test suite and generate implementation reports for implementers.</b></p>

    <p>&nbsp;</p>
    <div class="issue" id="issue-A">
        <div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
            <span>TODO B</span><span style="text-transform: none"></span>
        </div>
        <div class="">
            <p>
                Ecrire la doc

                BorderCloud/tft-jena-fuseki https://github.com/BorderCloud/tft-jena-fuseki
                BorderCloud/tft-virtuoso7-stable https://github.com/BorderCloud/tft-virtuoso7-stable
            </p>
        </div>
    </div>

    <section>
        <h5><a name="howto" id="howto"/>How to run the Test Cases in local with Docker</a></h5>

        <pre>
docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
docker pull bordercloud/tft-virtuoso7-stable
docker pull -t bordercloud/tft-jena-fuseki
docker run --privileged --name instance.tft_database -d bordercloud/tft-jena-fuseki
docker run --privileged --name instance.tft.example.org -h example.org -d bordercloud/tft-virtuoso7-stable
docker run --privileged --name instance.tft.example1.org -h example1.org -d bordercloud/tft-virtuoso7-stable
docker run --privileged --name instance.tft.example2.org -h example2.org -d bordercloud/tft-virtuoso7-stable
docker run --privileged --name instance.jena-fuseki -h tft-jena-fuseki -d bordercloud/tft-jena-fuseki
git clone --recursive https://github.com/BorderCloud/TFT.git
cd TFT
composer install --dev
php ./tft-testsuite -a -t fuseki -q http://172.17.0.2/test/query -u http://172.17.0.2/test/update
php ./tft -t fuseki -q http://172.17.0.2/test/query -u http://172.17.0.2/test/update -tt fuseki -tq http://172.17.0.6/test/query -tu http://172.17.0.6/test/update -r http://test.example.com -o ./junit --softwareName="Fuseki"  --softwareDescribeTag=v3.4.0 --softwareDescribe=v3.4.0
php ./tft-score -t fuseki -q http://172.17.0.2/test/query -u http://172.17.0.2/test/update -r  http://test.example.com
    </pre>
    </section>

    <section>
        <h5><a name="howto" id="howto"/>How to run the Test Cases in GitHub via Travis CI</a></h5>

        https://github.com/BorderCloud/tft-jena-fuseki/blob/master/.travis.yml
        <pre>
sudo: required

language: php
php:
  - '7.1'

notifications:
  email:
    recipients:
      - karima.rafes@gmail.com
    on_success: always # default: change (other : never)
    on_failure: always # default: always

env:
  global:
    - URI="https://travis-ci.org/BorderCloud/tft-jena-fuseki/builds/$((TRAVIS_JOB_ID - 1))"
    - NAME="Jena Fuseki"
    - SOFTWARE_DESCRIBE="Jena Fuseki"
    - VERSION="3.4.0"
    - SPARQLSCORE_DATABASE="172.17.0.6" #local

services:
  - docker

before_install:
  - docker pull bordercloud/tft-virtuoso7-stable
  - docker build -t tft-jena-fuseki .
#  - docker pull bordercloud/tft-jena-fuseki

script:
# Deploy TFT
# Run RDF database in order to save tests and results
  -   docker run --privileged --name instance.jena-fuseki -h tft-jena-fuseki -d tft-jena-fuseki

  -   docker run --privileged --name instance.tft.example.org -h example.org -d bordercloud/tft-virtuoso7-stable
  -   docker run --privileged --name instance.tft.example1.org -h example1.org -d bordercloud/tft-virtuoso7-stable
  -   docker run --privileged --name instance.tft.example2.org -h example2.org -d bordercloud/tft-virtuoso7-stable

##  -   docker run --privileged --name instance.tft_database -d tft-jena-fuseki

## Run quick test
#  -   docker run --privileged --name instance.jena-fuseki -h tft-jena-fuseki -d bordercloud/tft-jena-fuseki
#  -   docker run --privileged --name instance.tft.example.org -h example.org -d bordercloud/tft-virtuoso7-stable
#  -   docker run --privileged --name instance.tft.example1.org -h example1.org -d bordercloud/tft-virtuoso7-stable
#  -   docker run --privileged --name instance.tft.example2.org -h example2.org -d bordercloud/tft-virtuoso7-stable
#  -   docker run --privileged --name instance.tft_database -d bordercloud/tft-jena-fuseki

  -   git clone --recursive https://github.com/BorderCloud/TFT.git
  -   cd TFT
  -   composer install --dev
  -   php ./tft-testsuite -a -t fuseki -q http://${SPARQLSCORE_DATABASE}/test/query -u http://${SPARQLSCORE_DATABASE}/test/update
  -   php ./tft -t fuseki -q http://${SPARQLSCORE_DATABASE}/test/query -u http://${SPARQLSCORE_DATABASE}/test/update -tt fuseki -tq http://172.17.0.2/test/query -tu http://172.17.0.2/test/update -r ${URI} -o ./junit --softwareName="${NAME}"  --softwareDescribeTag=${VERSION}  --softwareDescribe="${TRAVIS_COMMIT}"
  -   php ./tft-score -t fuseki -q http://${SPARQLSCORE_DATABASE}/test/query -u http://${SPARQLSCORE_DATABASE}/test/update -r  ${URI}


after_success:
  - if [ "$TRAVIS_BRANCH" == "master" ]; then
    docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD ;
    docker push bordercloud/tft-jena-fuseki;
    fi
        </pre>
    </section>


    <section>
        <h5><a name="howto" id="howto"/>Share the report</a></h5>

        https://github.com/BorderCloud/tft-jena-fuseki/blob/master/.travis.yml
        <pre>
    - SPARQLSCORE_DATABASE="134.158.74.247"
#   - SPARQLSCORE_DATABASE="172.17.0.6" #local
        </pre>
    </section>
</section>



	<section>
		<h2>Reports</h2>
		<p>
			This section summarizes the outcomes of test reports of SPARQL implementation in docker image hosted by GitHub.
		</p>

		<div class="issue" id="issue-1">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 1</span><span style="text-transform: none"></span>
			</div>
			<div id="result" 
data-sgvizler-query="PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX mf: &lt;http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#&gt;
PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

SELECT  DISTINCT ?label
WHERE {
        GRAPH ?g {
 
    ?spec  mf:conformanceRequirement   ?collection .
        ?spec  rdfs:label   ?label .
        ?collection 	rdf:rest*/rdf:first  ?manifest .

      #?test a mf:CSVResultFormatTest;
          #     mf:name ?name .

}
}" 
data-sgvizler-endpoint="http://134.158.74.247/test/query" 
data-sgvizler-chart="sgvizler.visualization.Table" 
data-sgvizler-log="2" 
data-sgvizler-method="GET" 
></div>
		</div>

		<div class="issue" id="issue-1">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 2</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire la liste des erreurs pour ce logiciel coté syntaxe
			  </p>
			</div>
		</div>
		<div class="issue" id="issue-1">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 3</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire la liste des erreurs pour ce logiciel coté résultat
			  </p>
			</div>
		</div>

	</section>

  <section>
	<h2>Tests</h2>
  		<section>
		<h3>summary</h3>

    		<div class="issue" id="issue-2">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 4</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire une requête qui affiche les statistiques de chaque logiciel
			  Tests title	Link manifest		Software1(%) Software2(%)
			  </p>
			</div>
		</div>

		<div class="issue" id="issue-3">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 5</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
			  Faire une requête qui affiche les statistiques de chaque logiciel
			  Tests title	Link manifest		Percent for all
			  </p>
			</div>
		</div>
   	</section>

   	<section>
      <h3>Tests by Specifications</h3>
      			<section>
				<h4>SPARQL 1.1 Query Language</h4>
				<p>

				</p>

			<div class="issue">
			<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
				<span>TODO 6</span><span style="text-transform: none"></span>
			</div>
			<div class="">
			  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
			  </p>
			</div>
		</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Update</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 7</span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Query Results CSV and TSV Formats</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 8</span><span style="text-transform: none"></span>
				</div>
				<div id="resulth8"
        data-sgvizler-query="PREFIX mf: <http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#>
        prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
        prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
        SELECT distinct ?name
        WHERE {
        GRAPH ?g {
        ?test a mf:CSVResultFormatTest ;
        mf:name ?name .
        }
        }
        ORDER by ?name"
   data-sgvizler-endpoint="http://134.158.74.247/test/query"
   data-sgvizler-chart="sgvizler.visualization.Table"
   data-sgvizler-log="2"
   data-sgvizler-method="POST"
   ></div>

   
			</section>
			<section>
				<h4>SPARQL 1.1 Query Results JSON Format</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 9</span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Federation Extensions</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 10</span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Entailment Regimes</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 11</span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Service Description</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 12</span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Protocol</h4>
				<p>

				</p>

				<div class="issue" >
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 13 </span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
			<section>
				<h4>SPARQL 1.1 Graph Store HTTP Protocol</h4>
				<p>

				</p>

				<div class="issue">
				<div role="heading" class="issue-title marker" id="h-issue" aria-level="3">
					<span>TODO 14</span><span style="text-transform: none"></span>
				</div>
				<div class="">
				  <p>
				  reproduire le tableau dans cette partie
				  http://w3c.github.io/rdf-tests/sparql11/reports/
				  </p>
				</div>
			</section>
		</section>
	</section>
</section>

<section class="appendix" id="issue-summary">
  <!-- A list of issues will magically appear here -->
</section>


    <script src="node_modules/jquery/dist/jquery.slim.js"></script>
    <script src="node_modules/sgvizler2/build/browser/sgvizler2.js"></script>
    <script>

            sgvizler2.containerDrawAll();
    </script>
    <script
            src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
  </body>
</html>
